% Copyright 2012 Jeffrey Kegler
% This document is licensed under
% a Creative Commons Attribution-NoDerivs 3.0 United States License.
\documentclass[12pt]{amsart}
\usepackage{algorithm}
\usepackage{algpseudocode}

\newcommand{\comment}[1]{}
\newcommand{\sep}{\,\mid\,}
\newcommand{\mydot}{\raisebox{.15em}{\tiny $\,\bullet\,$}}
\newcommand{\size}[1]{\left | {#1} \right |} 
\newcommand{\order}[1]{{\mathcal O}(#1)}

\newcommand{\var}[1]{\ensuremath{\textbf{#1}}}

\newcommand{\cfg}{CFG}

\newcommand{\de}{\rightarrow}
\newcommand{\derivg}[1]{\mathrel{\mbox{$\:\Rightarrow\:$}}}
\newcommand{\derivrg}[2]{\mathrel{\mbox{$\:\stackrel{\!{#1}}%
        {\Rightarrow\!}\:$}}}

\newcommand{\ep}{\varepsilon}

\newcommand{\set}[1]{{\lbrace #1 \rbrace} }
\newcommand{\ah}[1]{#1_{AH}}
\newcommand{\Vah}[1]{\ensuremath{\var{#1}_{AH}}}
\newcommand{\bool}[1]{\var{#1}_{BOOL}}
\newcommand{\Vbool}[1]{\ensuremath{\bool{#1}}}
\newcommand{\dr}[1]{#1_{DR}}
\newcommand{\Vdr}[1]{\ensuremath{\var{#1}_{DR}}}
\newcommand{\Vdrset}[1]{\ensuremath{\var{#1}_{\set{DR}}}}
\newcommand{\eim}[1]{#1_{EIM}}
\newcommand{\Veim}[1]{\ensuremath{\var{#1}_{EIM}}}
\newcommand{\Veimt}[1]{\ensuremath{\var{#1}_{EIMT}}}
\newcommand{\Veimx}[1]{\ensuremath{\var{#1}_{EIMX}}}
\newcommand{\Veimm}[1]{\ensuremath{\var{#1}_{EIMM}}}
\newcommand{\Veimset}[1]{\ensuremath{\var{#1}_{\set{EIM}}}}
\newcommand{\Veimtset}[1]{\ensuremath{\var{#1}_{\set{EIMT}}}}
\newcommand{\Veimxset}[1]{\ensuremath{\var{#1}_{\set{EIMX}}}}
\newcommand{\Veimmset}[1]{\ensuremath{\var{#1}_{\set{EIMM}}}}
\newcommand{\es}[1]{#1_{ES}}
\newcommand{\Ves}[1]{\ensuremath{\var{#1}_{ES}}}
\newcommand{\Vesi}[2]{\ensuremath{\var{#1}[#2]_{ES}}}
\newcommand{\VVes}[2]{\ensuremath{\var{#1}[\var{#2}]_{ES}}}
\newcommand{\Vlim}[1]{\ensuremath{\var{#1}_{LIM}}}
\newcommand{\Vlimx}[1]{\ensuremath{\var{#1}_{LIMX}}}
\newcommand{\loc}[1]{\var{#1}_{LOC}}
\newcommand{\Vloc}[1]{\ensuremath{\loc{#1}}}
\newcommand{\Vrule}[1]{\ensuremath{\var{#1}_{RULE}}}
\newcommand{\sym}[1]{#1_{SYM}}
\newcommand{\Vsym}[1]{\ensuremath{\var{#1}_{SYM}}}
\newcommand{\symset}[1]{#1_{\lbrace SYM \rbrace} }
\newcommand{\Vsymset}[1]{\ensuremath{\var{#1}_{\set{SYM}}}}
\newcommand{\term}[1]{#1_{TERM}}
\newcommand{\token}[1]{#1_{TOK}}
\newcommand{\alg}[1]{\ensuremath{\textsc{#1}}}
\newcommand{\AH}{\ensuremath{\alg{AH}}}
\newcommand{\Earley}{\ensuremath{\alg{Earley}}}
\newcommand{\Leo}{\ensuremath{\alg{Leo}}}
\newcommand{\Marpa}{\ensuremath{\alg{Marpa}}}
\newcommand{\Emulator}{\ensuremath{\alg{Emulator}}}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}

\theoremstyle{definition}
\newtheorem*{definition}{Definition}

\theoremstyle{remark}
\newtheorem*{remark}{Remark}

\DeclareMathOperator{\scanned}{scanned}
\DeclareMathOperator{\Hyp}{Hyp}
\DeclareMathOperator{\GOTO}{GOTO}
\newcommand\myL[1]{\operatorname{L}(#1)}
\newcommand\tables[1]{\es{\operatorname{table}(#1)}}

% I want to use 'call' outside of pseudocode
\newcommand\call[2]{\textproc{#1}\ifthenelse{\equal{#2}{}}{}{(#2)}}%

\hyphenation{ALGOL}

\begin{document}

\title{Marpa, a practical general parser: the recognizer}

\author{Jeffrey Kegler}
\thanks{
Copyright \copyright\ 2012 Jeffrey Kegler.
This document is licensed under
a Creative Commons Attribution-NoDerivs 3.0 United States License.
}

\begin{abstract}
This document reports describes the recognizer portion
of the Marpa algorithm.
The Marpa algorithm is a practical, and fully implemented,
algorithm for the recognition,
parsing and evaluation of context-free grammars.
Marpa's recognizer is based
on Earley's algorithm,
and merges the improvements to Earley's
from Leo~\cite{Leo1991}
and Aycock and Horspool~\cite{AH2002}.
Their combination in the Marpa parse engine
has an added feature:
as tokens are being scanned,
full knowledge of the state of the parse is available.
Advantageous for error detection,
this also allows input to be altered as the parse progresses,
which is an extremely powerful technique.
\end{abstract}

\maketitle

\section{THIS IS AN EARLY DRAFT}

This a very early draft of this document,
and is largely unchecked.
The spirit and culture of the open source community
dictate that works of this kind and
at even this very early stage be made
available on-line in public repositories.
The reader should see the availability of this document
as compliance with that spirit and culture,
and not as in any way suggesting or
encouraging reliance on its contents.

\section{Introduction}

Despite the promise of general context-free parsing,
and the strong academic literature behind it,
it has never been incorporated into a tool
as widely available as yacc or
regular expressions.
The Marpa project was begun to end this neglect by
turning the best results from that literature
into a widely-available tool.
A stable version of this tool, Marpa::XS~\cite{Marpa-XS},
was uploaded to the CPAN Perl archive
on Solstice Day in 2011.

\section{Preliminaries}
\label{s:prel}

I assume familiarity with standard grammar notation
(pages 14-15 in Aho and Ullman~\cite{AU1972}).
In the past,
the type system required to support
a theory of parsing has been seen
as a challenge to the typographic
imagination,
often to become one to the eyesight.
This document will 
often use subscripts to indicate the commonly occurring types.
For example, $\sym{a}$ and $\sym{X}$ will be symbols.

Where $Abc$ is a set of symbols,
let $Abc^\ast$ be the set of all strings formed
from those symbols.
Let $Abc^+$ be the subset of $Abc^\ast$ that
contains all of its elements that are not of zero length.

For the purposes of this document consider,
without loss of generality,
a grammar $g$,
and a set of symbols, $alphabet$.
Call the language of \var{g}, $\myL{g}$,
where $\myL{g} \in alphabet^\ast$
Let its input be \var{w}, $\var{w} \in \var{alphabet}^\ast$.
Divide $alphabet$ into two disjoint sets,
$lh$ and $term$.

For the rewriting, designate a set of duples, $rules$,
where $\forall \Vrule{r} \sep \Vrule{r} \in rules$,
\Vrule{r} takes the form $\Vsym{lhs} \de \Vsymset{rhs}$,
where $\sym{lhs} \in term$ and 
$rhs \in alphabet^+$. 
\Vsym{lhs} is referred to as the left hand side (LHS)
of \Vrule{r}.
\Vsymset{rhs} is referred to as the right hand side (RHS)
of \Vrule{r}.
This definition follows \cite{AH2002},
which departs from tradition by disallowing an empty RHS.

The grammar $g$ can be defined as the 4-tuple
$$(\Vsymset{alphabet}, \Vsymset{term}, rules, \Vsym{start})$$.
Without loss of generality,
it is assumed that $g$ is "augmented",
so that \Vsym{start} is a dedicated start symbol
and
$\Vrule{start} = [ \Vsym{start} \de \Vsym{goal} ] $
is a dedicated start rule
such that for every rule, $\Vrule{x} = [ \Vsym{lhs} \de \Vsymset{rhs} ]$
\begin{center}
\begin{tabular}{ll}
1.\hspace{.5em} & 
$  \Vsym{start} = \Vsym{lhs} \implies \Vrule{x} = \Vrule{start} $ \\
2. &
$  \Vsym{start} \notin \Vsymset{rhs} $ \\
\end{tabular}
\end{center}

We have already noted
that no rules of \var{g}
have a zero-length RHS.
Further, no rule can be nullable
and all symbols must be either nulling or non-nullable --
no symbol can be a proper nullable.
These restrictions follow Aycock and Horspool~\cite{AH2002}.
The elimination of empty rules and proper nullables
is done by rewriting the grammar.
This can be done without loss of generality
and, in their paper~\cite{AH2002},
Aycock and Horspool
show how to do this
without effect on the time complexity
as a function of the input size.
Very importantly,
this rewrite is done in such a way that the semantics
of the original grammar can be efficiently reconstructed
at evaluation time.

Aycock and Horspool did allow a single empty start rule
to deal with null parses.
Marpa completely eliminates the need for empty rules in its grammars
by treating null parses and trivial grammars as special cases.
(Trivial grammars are those which recognize only the null string.)

In this document, \Earley{} will refer to the Earley's original
recognizer~\cite{Earley1970}.
\Leo will refer to Leo's revision of \Earley
as described in~\cite{Leo1991}.
\AH will refer to the Aycock and Horsool's revision
of \Earley
as described in~\cite{AH2002}.
Where $\alg{Recce}$ is a recognizer,
$\myL{\alg{Recce},g}$ will be the language accepted by $\alg{Recce}$
when parsing grammar $g$.

\section{The AHFA Finite Automaton}
\label{s:AHFA}

In this document a
"split LR(0) $\epsilon$-DFA"
a described by Aycock and Horspool~\cite{AH2002},
will be called an Aycock-Horspool Finite Automaton,
or AHFA.
A full description of how to derive an AHFA in theory
can be found in \cite{AH2002},
and examples of how to derive it in practice
can be found in the code for Marpa\cite{Marpa-RS,Marpa-XS}.
Here I will summarize those ideas behind AHFA's
that are central to Marpa.

Aycock and Horspool based their AHFA's
on a few observations.
\begin{itemize}
\item
In practice, Earley items with the same dotted rule
often appear in groups in the Earley sets,
where the entire shares the same origin.
\item
There was already in the literature a method
for associating groups of dotted rules that often appear together
when parsing.
This method was the LR(0) DFA used in the much-studied
LALR and LR parsers.
\item
The LR(0) items that are the components of LR(0)
states are, exactly, dotted rules.
\item
By taking into account symbols which derive the
null string, the LR(0) DFA could be turned into an
LR(0) $\epsilon$-DFA, which would be even more effective
at grouping dotted rules which occur together.
\end{itemize}

AHFA states are sets of dotted rules.
Aycock and Horspool realized that by changing Earley items
to track AHFA states, instead of individual dotted rules,
the size of Earley sets could be reduced,
and Earley's algorithm made faster in practice.
In short, then, AHFA states are a shorthand that Earley items
can use for groups of dotted rules that occur together frequently.
The original Earley items could be represented as $(\Vdr{r}, origin)$
duples, where \Vdr{r} is a dotted rule.
Aycock and Horspool modified their Earley items to be $(\ah{L}, origin)$
duples, where $\ah{L}$ is an AHFA state.

\begin{definition}
The {\bf $\epsilon$-transition } partial function forms dotted rule from another
by moving the dot forward.
The {\bf $\epsilon$-closure } of a dotted rule
is the set of dotted rules
that can be formed by 
$\epsilon$-transition and its inverse.
$\epsilon(\Vdr{d})$ is the $\epsilon$-closure of \Vdr{d}.
The {\bf $\epsilon$-closure } of a set of dotted rules is the union
of their $\epsilon$-closures.
$\epsilon(\Vdrset{ds})$ is the $\epsilon$-closure of \Vdrset{ds}.
\end{definition}

\begin{definition}
A dotted rule is {\bf Marpa-valid} if and only if
it does not have a nulling postdot symbol.
One and only one dotted rule of every
{\bf $\epsilon$-closure } will be Marpa-valid.
\end{definition}

\begin{definition}
In \cite{AH2002}, {\bf $\epsilon$-transition } is also defined for AHFA states.
The {\bf AHFA $\epsilon$-sets} are the sets formed by the closure
of $\epsilon$-transition for AHFA states.
\end{definition}

No AHFA $\epsilon$-set contains more than two AHFA states.
If an AHFA $\epsilon$-set contains one AHFA state, it is either
the initial AHFA state or a discovered state
(what in \cite{AH2002} are called the "kernel states").
If an AHFA $\epsilon$-set contains two AHFA states, the from-state
is either the initial AHFA state or a discovered state,
and the to-state is always a predicted state.

It is important to note that
an AHFA is not a partition of the dotted
rules --
a single dotted rule can occur
in more than one AHFA state.
This does not happen frequently,
but it does happens often enough,
even in practical grammars,
that the Marpa implementation has to provide for it.

What does not seem to happen in practical grammars
the size of \AH Earley set to grow larger
than that of one of Earley's original sets.
That is, it seems the AHFA is always a win,
at least for practical grammars.

Use of the AHFA states in EIM's can
be proved to be break-even for
time and space complexity purposes.
The next observation is useful for that purpose.

\begin{lemma}
Let $g$ be a grammar as defined in this
document,
and let $fa$ be the AHFA for this grammar.
Let $\var{S-t}$ be
Earley set $i$ of a traditional earley parse.
Let $\var{S-m}$ be an set
of Earley items of the Aycock-Horspool form (EIMA),
such that
\begin{gather*}
\forall r, origin
\exists \ah{state} \sep \\
[\Vdr{r}, origin] \in \var{S-t} \\
\implies
\ah{state} \in fa
\land \Vdr{r} \in \ah{state}
\land [\ah{state}, origin] \in \var{S-m}
\end{gather*}
Then 
$\size{\var{S-m}} < c \times \size{\var{S-t}}$,
where $c$ is the number of states in $fa$.
\end{lemma}

\begin{proof}
The worst case is that every rule of 
$\var{S-t}$ has a different $origin$,
Worst case for grouping dotted rules into $c$ unique states
is that every dotted rule appears in $c - 1$ states.
$\size{\var{S-t}} < c \times \size{\var{S-m}}$.
\end{proof}

\section{The Leo algorithm}

\begin{theorem}\label{t:leo-singleton}
If the AHFA state of
a Marpa Earley item (EIMM) is the result of a
Leo completion,
then its AHFA state contains only one dotted rule.
\end{theorem}

\begin{proof}
Since the Earley item is the result of a Leo completion,
we know that its AHFA state contains a completed rule.
Call that completed rule, \Vdr{complete}.
Let \Vrule{c} be the rule of \Vdr{complete},
and \var{cp} its dot position.
$\var{cp} > 0$ because completions are never
predictions.

Suppose, for a reduction to absurdity,
and that the AHFA state contains another dotted rules,
\Vdr{other},
$\Vdr{complete} \neq \Vdr{other}$.
Let \Vrule{o} be the rule of \Vdr{other},
and \var{op} its dot position.
An AHFA construction never places predictions in the same
AHFA state as a completion, so
\Vdr{other} is not a prediction.
Therefore, $\var{op} > 0$.

To create a contradiction, we first prove that
$\Vrule{c} \neq \Vrule{o}$,
then that 
$\Vrule{c} = \Vrule{o}$.
By the construction of an AHFA
state, both dotted rules resulted from the same series
of transitions.
But the same series of transitions over the
same rule would result in the same dot position,
$\var{cp} = \var{op}$
so that if $\Vrule{c} = \Vrule{o}$,
$\Vdr{complete} = \Vdr{other}$,
which is contrary to the assumption for the reduction.
Therefore, under the assumption for the reduction,
$\Vrule{c} \neq \Vrule{o}$.

Next we show that, under the assumption for the reduction,
that $\Vrule{c} = \Vrule{o}$
follows from Leo's uniqueness requirement.
Since both dotted rules are in the same EIMM
and neither is a predictions,
both must result from transitions,
and their transitions must have been from the same Earley set.
Since they are in the same AHFA state,
by the AHFA construction,
that transition must have been
over the same transition symbol.
Leo requires that, for each predecessor Earley set and transition symbol,
that the transition be from a single rule.
The assumption for the reduction is that \Vdr{complete}
and \Vdr{other} are in the same Leo completion state,
and in order for them to have obeyed the Leo uniqueness
requirement,
we have $\Vrule{c} = \Vrule{o}$.

We now have both
$\Vrule{c} = \Vrule{o}$
and 
$\Vrule{c} \neq \Vrule{o}$,
completing the reduction to absurdity.
When \Vdr{complete} is in a Leo completion EIMM,
it must be the only dotted rule in that EIMM.
\end{proof}

\section{The Marpa Recognizer}
\label{s:recce}

\begin{algorithm}[H]
\caption{Marpa Initialization}\label{a:initial}
\begin{algorithmic}[1] 
\Procedure{Initial}{}
\State \Call{AddItems}{$0, \ah{start}, 0$}
\EndProcedure
\end{algorithmic} 
\end{algorithm}

\begin{algorithm}[H]
\caption{Marpa Scanning}\label{a:scan}
\begin{algorithmic}[1] 
\Procedure{Scan}{$i,a$}
\For{each Earley item $\eim{x}$ in $ES[i]$}
\State $\ah{to} \gets \GOTO(\operatorname{AHFA-of}(\eim{x}), a)$
\State \Call{Add EIM Pair}{$i+1, \ah{to}, \operatorname{Origin-of}(\eim{x}$}
\EndFor
\EndProcedure
\end{algorithmic} 
\end{algorithm}

\begin{algorithm}[H]
\caption{Collection phase}\label{a:collection-phase}
\begin{algorithmic}[1] 
\Procedure{Collection phase}{$i_{LOC}$}
\For{each Earley item $\Veim{work} \in \var{earley-sets}[i]$}
\State $[\Vah{work}, \Vloc{origin}] \gets \Veim{work}$
\For{each lhs of a completed rule, $\Vsym{lhs}$}
\For{each postdot item $pim$, in $\var{transitions}(\Vloc{origin},\Vsym{lhs})$}
\If{\var{pim} is a LIMX, \Vlimx{pim}}
\State $\Vlimx{pred} \gets \var{pim}$
\State \Call{Leo Collection Operation}{\Vloc{i}, \Vlimx{pred}}
\Else
\State $\Veimx{pred} \gets \var{pim}$
\State \Call{Earley Collection Operation}{\Vloc{i}, \Veimx{pred}, \Vsym{lhs}}
\EndIf
\EndFor
\EndFor
\EndFor
\For{all postdot symbols in Earley set $i$, \Vsym{postdot}}
\State Set $var{transitions}(i, \Vsym{postdot})$ to an LIMX or a set of EIMX's, as appropriate
\EndFor
\EndProcedure
\end{algorithmic} 
\end{algorithm}

\begin{algorithm}[H]
\caption{Earley Collection Operation}\label{a:earley-collection-op}
\begin{algorithmic}[1] 
\Procedure{Earley collection op}{\Vloc{i}, \Veim{from}, \Vsym{trans}}
\State $[\Vah{from}, \Vloc{origin}] \gets \Veim{from}$
\State $\ah{to} \gets \GOTO(\Vah{from}, \Vsym{trans})$
\State \Call{Add EIM Pair}{\Vloc{i}, \Vah{to}, \Vloc{origin}}
\EndProcedure
\end{algorithmic} 
\end{algorithm}

\begin{algorithm}[H]
\caption{Adding EIM Pairs}\label{a:pair}
\begin{algorithmic}[1] 
\Function{Add EIM Pair}{$i_{LOC},\ah{discovered},origin_{LOC}$}
\State $\ah{predicted} \gets \Lambda$
\State $\eim{discovered} \gets \Lambda$
\If{$\ah{to} \neq \Lambda$}
\State $\eim{discovered} \gets [\ah{to}, origin_{LOC}]$
\If{$\eim{discovered}$ is new}
\State Add $\eim{discovered}$ to $ES[i]$
\State $\ah{predicted} \gets \GOTO(\ah{to}, \epsilon)$
\EndIf
\EndIf
\If{$predicted_{AHFA} \neq \Lambda$}
\State $\eim{predicted} \gets [\ah{predicted}, i]$
\If{$eim{predicted}$ is new}
\State Add $\eim{predicted}$ to $ES[i]$
\EndIf
\EndIf
\State \textbf{return} $\eim{discovered}$
\EndFunction
\end{algorithmic} 
\end{algorithm} 

\section{Marpa recognizer correctness}
\label{s:marpa:correctness}

\subsection{Proof strategy}

Marpa's correctness will shown based the correctness
proved for \Leo{} in~\cite{Leo1991}.
The proof will be by induction
on the operations of the two recognizers.
For this induction,
the operations will need to happen
in the same order.
This will be accomplished by constructing a third
recognizers, \alg{Emulator}, which will,
in effect, emulate \Marpa{} using \Leo{}.
of operations.

\subsection{The emulator}

\Emulator{} will be \Leo,
with the following modifications.

\subsubsection{Calculating the AHFA}

\Emulator, as part of its precomputations
on its grammar, \var{g},
will calculate \var{ah}, the AHFA
It will also calculate $\GOTO: \var{ah},\var{alphabet} \mapsto \var{ah}$,
the transition function for \var{ah}.

\subsubsection{Extending the Earley items}

The Earley sets of \Emulator{} will contain extended
Earley items, EIMX's.  Each EIMX will have the form
$$[\Vbool{active}, \Vah{state}, \Vdr{dr}, \var{origin}]$$
where
\Vah{state} is an AHFA state,
\Vdr{dr} is a dotted rule,
\var{origin} is the origin,
and \Vbool{active} is a boolean whose use will be
explained.
EIMX's can be viewed as
crosses (``X") between traditional Earley items (EIMT's)
and Marpa's Earley items (EIMM's).

\subsubsection{Extending the Leo items}

Leo items (LIM's) will also be extended.
The extended Leo items will take the form
$$[\Vbool{active}, \Vah{state}, \Vdr{dr}, \Vsym{trans}, \var{origin}]$$
where 
$$[\Vdr{dr}, \Vsym{trans}, \var{origin}]$$ is the original
Leo item,
\Vah{state} is the state of the Leo discovery item
that will be added when the Leo item is used,
and \Vbool{active} is a boolean whose use will be
explained.

\subsubsection{Leo-Emulator Congruence}

A set of EIMX's (\Veimxset{X}) and a set of EIMT's
(\Veimset{T})
are congruent 
$$\Veimtset{X} \cong \Veimtset{T}$$
if and only if
for all
Vdr{x}, \var{xorig}
\begin{gather*}
(\exists \Vah{x} \sep \Vah{x}, \Vdr{x}, \var{xorig} \in \Veimxset{X}) \\
\iff [\Vdr{x}, \var{xorig}] \in \Veimtset{T}
\end{gather*}

\subsubsection{The emulation engine}

For scanning, discovery and prediction,
\Emulator{} follows
the \Leo{} logic,
except that it uses EIMX's instead of EIMT's.
\Emulator{} runs through each Earley set repeatedly,
until no new EIMX's can be added.
EIMX's are never added if they are duplicates,
and the number of possible EIMX's for a given Earley set
is finite,
so that we know the loop will terminate.

\Veimx{a} and \Veimx{b} are considered duplicates if
\begin{gather*}
\Veimx{a} = [\Vbool{a}, \Vah{a}, \Vdr{a}, \Vloc{a}] \\
\land \Veimx{b} = [\Vbool{b}, \Vah{a}, \Vdr{a}, \Vloc{a}]
\end{gather*}
Two EIMX's which differs only in their active boolean
are considered identical.
It is quite possible that two EIMX's may differ when
their corresponding EIMT's are duplicates --
EIMX's are not duplicates
if they differ in their AHFA states.

\Leo{}, when traversing its Earley sets,
expects EIMT's.
\Emulator, during its processing of its Earley sets,
will encounter EIMX's.
Let the EIMX that \Emulator{} encounters be
$$\Veimx{cause} =
[\Vbool{active}, \Vah{state}, \Vdr{dr}, \var{origin}]$$
\Veimx{cause} may be enountered
as the predecessor in a scan operation;
as the predecessor or component in a discovery operation;
or as the predecessor in a prediction operation.
In each of these cases,
\Emulator{} first checks the
\var{active} boolean of the EIMX.
If it is false, the Emulator ignores the EIMX
as if it did not exist.
If \Vbool{active} is true, treats \Veimx{cause} as
if it were the following EIMT:
$$[\Vdr{dr}, \var{origin}]$$
Informally, it can be said that
\Emulator{} strips its extended information from an active EIMX,
and ignores inactive EIMX's.

Similarly, 
while \Leo{} uses LIM's,
during \Emulator{} will encounter LIMX's.
LIMX's are encountered as predecessors
during Leo discovery.
Let an encountered LIMX be
$$\Vlimx{predecessor} = [\Vbool{active}, \Vah{state}, \Vdr{dr}, \Vsym{trans}, \var{origin}]$$
\Emulator{} first checks the
\var{active} boolean of the LIMX.
If it is false, the Emulator ignores the LIMX
as if it did not exist.
If \Vbool{active} is true, treats \Vlimx{predecessor} as
if it were the following LIM:
$$[\Vdr{dr}, \Vsym{trans}, \var{origin}]$$
Informally, for use in Leo discovery,
\Emulator{} strips its extended information from an active LIMX,
and ignores inactive LIMX's.

Once it has found the causes for an Earley operation,
\Emulator{} proceeds to determine
\Vah{new} and \Vah{predict},
two AHFA states.
It does this as follows:
\begin{itemize}
\item
If it is scanning \Vsym{token},
$Vah{new} = \GOTO(\Vah{predecessor}, \Vsym{token})$,
where 
where \Vah{predecessor} is the AHFA state of the predecessor EIMX.
\item
If it is discovering, and Leo discovery does not
apply, then
$Vah{new} = \GOTO(\Vah{predecessor}, \Vsym{lhs})$,
where \Vah{predecessor} is the AHFA state of the predecessor EIMX.
and \Vsym{lhs} is the LHS of the completed rule.
\item
If it is discovering, and Leo discovery does apply,
$\Vah{new} = \Vah{leo}$, where \Vah{leo} is
the state in the extended Leo item.
Leo discovery in the \Emulator{}
will be described below.
\Vah{predict} is set to $\GOTO(\Vah{predecessor}, \epsilon)$
\item For predictions, $\Vah{new} = \Lambda$.
Call \Vah{cause}, the AHFA state of the EIMX that caused
the prediction.
If \Vah{cause} is itself a prediction, $\Vah{predict} = \Vah{cause}$.
If \Vah{cause} is not a prediction, $\Vah{predict} = \GOTO(\Vah{cause}, \epsilon)$.
\end{itemize}

If $\Vah{new} \neq \Lambda$,
\Emulator{} produces the \Veimtset{discovered}, where
\begin{equation*}
\Veimtset{discovered}  =
\set{ [ \Vah{new}, \Vdr{dr}, \var{origin} ] \sep \Vdr{dr} \in \epsilon(\Vah{new}) }
\end{equation*}
where \var{origin} is the origin of \Veimt{new},
and 
$\epsilon(\Vah{new})$ is the $\epsilon$-closure of the dotted rules in \Vah{new}.
The EIMX's from 
\Veimtset{discovered} are added to the current Earley set
in Emulator Dotted Rule Order.
Emulator Dotted Rule Order is some fixed, total
ordering,
which must order completed rules
in Emulator Dotted Symbol Order by LHS.
(The order must be fixed
so that that it can be
shared with \Marpa{}.)

Next, if $\Vah{predict} \neq \Lambda$,
\Emulator{} produces,
for every EIMX in the $\epsilon$-closure of \Vah{new},
$${ [ \Vah{predict}, \Vdr{dr}, \var{current} ] \sep \Vdr{dr} \in \epsilon(\Vah{predict}) }$$
where \var{current} is the current Earley set.
The EIMX's from 
\Veimtset{predicted} are added to the current Earley set
in Emulator Dotted Rule Order.

\subsubsection{Creating Leo items}

Unlike \Leo,
\Emulator{} compute the LIMX's on an eager basis,
immediately
after each Earley set is finished.
This is possible because there is enough information
in the Earley set to identify potential LIM's.

\subsubsection{Initialization in the Emulator}

It is convenient to treat \Emulator{}
initialization is handled as a special case.
To build Earley set 0, \Emulator{}
first adds the set
\begin{equation*}
\set{ [ \Vah{start}, \Vdr{dr}, 0 ] \sep \Vdr{dr} \in \epsilon(\Vah{start}) }
\end{equation*}
in Dotted Rule Order.
It then examines \Vah{prediciton},
where $\Vah{prediction} = \GOTO(\Vah{cause}, \epsilon)$.
If $\Vah{prediction} \neq \Lambda$,
Emulator adds the set
\begin{equation}
\set{ [ \Vah{predicted}, \Vdr{dr}, 0 ] \sep \Vdr{dr} \in \epsilon(\Vah{predicted}) }
\end{equation}
in Emulator Dotted Rule Order.

\section{Leo mode}

The emulator runs in modes.
The intent of Leo mode is to emulate \Leo.
\Emulator{} is "eager" in its creation of Earley items.
The idea behind the following rules is
that the active boolean tracks
whether \Leo{} would have created the EIMX.
\begin{itemize}
\item EIMX's in Earley set 0 are always
created with their active booleans
set to true, regardless of any other rules.
\item The EIMX of the base EIMX is set to true.
This is the case whether the base EIMX is being created,
or already exists.
\item If an EIMX already exists,
and it is not the base EIMX,
it active boolean is left as it was.
\item If an EIMX does not exist,
and is being created,
it is created with its active boolean set to false.
\item When an LIMX is created, its active boolean is set to false.
\item When an LIMX is used in Leo discovery, its active boolean
is set to true.
\item
Once the active boolean of an EIMX or LIMX is true, its value
will never change.
\end{itemize}

\section{The emulator in Leo mode is correct}

We now show that,
for a given grammar \var{g} and input \var{w},
the Earley sets of \Emulator{} are always congruent
to those of \Leo.

\begin{theorem}
Let $\operatorname{L}[i]$
be Earley set $i$ in \Leo,
and $\operatorname{E}[i]$
be Earley set $i$ in \Emulator.
\begin{equation*}
\forall i \sep 0<i<\size{w} \implies
\operatorname{L}[i] \cong \operatorname{E}[i]
\end{equation*}
\end{theorem}

\begin{proof}
We assume that \Emulator{} is in Leo mode.
It is straightforward to confirm that
$$ \operatorname{L}[0] \cong \operatorname{E}[0]$$
We next consider
Earley operations in the sets after Earley set 0.
By construction,
the definition of \Emulator{} in \Leo{} mode is
an extension of the definition of \Leo.
The Earley operations of \Emulator
will produce Earley sets where the every EIMX
corresponds to an EIMT created by \Leo.
Congruence follows directly.
\end{proof}

\section{Marpa mode}

Marpa mode uses "eager" activation.
In Marpa mode,
all EIMX's and LIMX's are created with their active
boolean set to true.
Once set to true, an active boolean remains true.

\section{The emulator in Marpa mode is correct}

To prove correctness,
we show that the emulator in Marpa mode produces
the same Earley sets as the emulator in Leo mode.

\begin{lemma}
An emulator with eager activation of Leo items,
produces the same Earley sets as the emulator with
lazy activation of Leo items.
\end{lemma}

\begin{proof}
Inspection of the logic will show that the active boolean
of the LIMX
is useless bookkeeping, without effect on the Earley sets.
\end{proof}

An EIMX is correct in Earley set $i$
if and only if its corresponding EIMT would
also be in Earley set $i$.

\begin{lemma}\label{l:eimx-correct}
All EIMX's, whether active or not,
are correct.
\end{lemma}

\begin{proof}
The proof is by cases:
the base EIMX;
EIMX's occurring in the AHFA state as the base EIMX;
EIMX's occurring in a predicted state;
and EIMX's from epsilon-closures in either of the two AHFA states.

\begin{itemize}
\item The base EIMX is correct because it results from
the \Leo{} logic, which is known to be correct\cite{Leo1991}.
\item The EIMX's occurring in the same AHFA state
as the base EIMX are correct, as shown in \cite{AH2002}.
\item The EIMX's occurring in a predicted AHFA state
as the base EIMX are correct, as shown in \cite{AH2002}.
\item The dotted rules produced by $\epsilon$-closure are
correct, because $\epsilon$-closure is as defined for
the traditional Earley's algorithm.
\end{itemize}

\end{proof}

\begin{lemma}\label{l:lazy-complete}
Even with lazy activation of EIMX's,
all EIMX's in Earley set $i$
will be active once processing for Earley set $i$
is complete.
\end{lemma}

\begin{proof}
By Lemma \cite{l:eimx-correct},
all EIMX's created by the emulator engine are
correct.
Lazy activation simulates Leo and Leo has been
shown to include all the correct EIMT's
in every Earley set.
For every EIMT created by \Leo,
lazy activation activate all the corresponding
EIMX's.
Therefore lazy activation activates all the
EIMX's in any \Emulator{} Earley set.
\end{proof}

\begin{lemma}
An emulator with eager activation of Earley items,
produces the same Earley sets as the emulator with
lazy activation of Earley items.
\end{lemma}

\begin{proof}
The proof is by induction on the Earleys sets.
The two modes do not differ for Earley set 0.
We proceed to show that if eager and lazy activation
have produced identical Earleys sets 0 through $i - 1$,
then the two activation methods will also produce
identical Earleys sets at $i$.

By Lemma \cite{l:lazy-complete},
once processing for an Earley set is complete,
all of its EIMX's are activated,
whether activation is lazy or eager,
and activated EIMX's never change their activation status.
This means that to show that the Earley sets
are identical we need to show that each
operation creates the same EIMX's
under both modes.
It also means that
an operation will behaves
differently under lazy activation and
eager activation only if it
depends on an EIMX in the current Earley set.

We examine those cases where
creation of an Earley item in Earley set $i$,
depends on another Earley item in Earley set $i$.
For scanning, the predecessor EIMX must be
in the previous Earley set, so that
this will never be the case.
Scanning therefore produces the new
EIMX's
whether activation is lazy or eager.

For prediction, the predecessor EIMX will always
be in the current Earley set.
But the predecessor EIMX, when it created
and activated EIMX's for all the dotted rules in its
AHFA state pair, created and activated of its
predictions.
This means that all predictions will already
exist and be activated before any \Emulator
prediction operation.
There an Emulator prediction operation will
always create duplicate EIMX's,
and since duplicates are not added,
will not change the Earley set.

For discovery,
we now show,
for eager activiation,
the basis of an induction on
the discovery loop's visits to
the potential component Earley items in an Earley set.
We note from the forgoing that, under eager activation,
all non-discovered Earley items exist and are active,
before the emulator's discovery loop begins.
Scanned items already exist and are active because scanning
was done first and we have just shown it complete and correct.
Prediction will come afterwards, but we have just shown it
will not add new EIMX's or activate any old ones.

The \Leo pseudocode (and therefore \Emulator) creates
discovered EIMX's by repeatedly looping
through potential component EIMX's,
looking for predecessor's as it goes.
Because we are running in eager mode,
we can rely on all of these component EIMX's being already
active.
Marpa allows no nullable rules, so component
will be zero length,
and the EIMX's predecessors must be in previous Earley sets.
For for every potential component, its matching
predecessors will exist and be active when the component is visited.
The logic will always add the discovered EIMX's.
That these are identical to those that would be added
under lazy activation can be seen by noting that once
the causes are identified and the active status checked,
both use the same logic.
This shows the induction step on the eager discovery
loop, and the induction on eager discovery.

Since prediction, scanning and discovery create
the same EIMX's in the two modes,
and, and since in either mode, all are activated when
the Earley set is finished,
we have shown the induction step for the Earley sets.
This completes the induction on the Earley sets,
and the proof.
\end{proof}

\subsection{Marpa is correct}

A set of EIMX's (\Veimxset{X}) and a set of EIMM's
(\Veimset{M})
are congruent 
$$\Veimtset{X} \cong \Veimtset{M}$$
if and only if
for all
\Vah{x}, \var{xorig}
\begin{gather*}
\Vbool{x}, \Vah{x}, \Vdr{x}, \var{xorig} \in \Veimxset{X} \\
\iff [\Vah{x}, \var{xorig}] \in \Veimmset{M}
\end{gather*}

\subsection{Refining the order of operations}

For normal operation of 
\Leo and \Marpa, the precise order of items in the Earley sets is not
important,
and the pseudocode for each leaves that order open.
To simplify the induction on operations in the correctness
proof, however, it is convenient to synchronize the operations
of \Emulator{} in Marpa mode,
with those of Marpa.
For this purpose, we treat the Earley sets as ordered sets,
which containing the Earley item in the order in which
they were added.

Call Emulation Symbol Order,
some total ordering of the symbols.
Emulation Symbol Order may be arbitrary but must stay fixed for the life
of the induction.

Call some total ordering of the dotted rules,
Emulation Dotted Rule Order.
This ordering must place completed rules in Emulation Symbol Order by
LHS.
Otherwise, Emulation Dotted Rule Order
may be arbitrary except that it
must stay fixed for the life
of the induction.

We refine the order of operations as follows:
Both \Emulator{} and \Marpa{},
when scanning, scan the tokens in
Emulation Symbol Order.
Both \Marpa{},
in considering the left hand sides of completed rules
during discovery,
does so in Emulation Symbol Order.
Both \Emulator{} and \Marpa{},
when creating Earley set 0,
create it in order by Emulation Dotted Rule
Order within AHFA state.
Finally, \Emulator{},
when adding the EIMX's for an AHFA state,
does so in Emulator Dotted Rule Order.
Together,
Emulator Symbol Order
and Emulator Dotted Rule Order are
referred to as Emulator Order.

For Earley sets after Earley set 0,
we require that the order of Earley items follow the
order in which they were added.
This definition ensures that,
that all EIMX's belonging
to the same AHFA state occur together
in an Earley set.
It is possible for the \Emulator{} to attempt
to add EIMX's belonging to a 
single AHFA state at several points while building
an Earley set, but when the first EIMX of an AHFA
state is added, all its co-occurring EIMX's are added
as well,
so that later attempts to add EIMX's in that AHFA state
will be rejected as attempts to add duplicates.

We now show that,
for a given grammar \var{g} and input \var{w},
the Earley sets of \Emulator{} are always congruent
to those of \Marpa.

\begin{theorem}
Assume that \Emulator{} is in Marpa mode,
and that the \Marpa{} and
\Emulator{} operate using
Emulator Order.
Let
$\operatorname{E}[i]$
be Earley set $i$ in \Emulator.
and $\operatorname{M}[i]$
be Earley set $i$ in \Marpa,
\begin{equation*}
\forall i \sep 0<i<\size{w} \implies
\operatorname{E}[i] \cong \operatorname{M}[i]
\end{equation*}
\end{theorem}

\begin{proof}
The proof is by double induction.
The outer induction is on the Earley sets,
and the inner induction on "basic operations".

We define the "basic operations" by breaking
down the operations of \Emulator and \Marpa
into convenient pieces, excluding
operations which can be shown
to have no effect on the Earley sets.
A basic operation is
\begin{itemize}
\item
A scan for one pairing of predecessor and token.
\item
An Earley collection for one pairing of predecessor and LHS.
\item
An Leo collection for one pairing of predecessor and LHS.
\end{itemize}
Predictions are not among the basic operations
because, as shown previously,
they have no effect on the Earley sets in \Emulator's Marpa mode.
Predictions do not exist in \Marpa.

The hypothesis for the outer induction is that
$$\forall \var{i} \sep 0<\var{i}<\var{n}
\implies
\VVes{EM}{i} \cong \VVes{M}{i}$$
and that
$\VVes{EM}{i}$ is in Emulation Order.

It is straightforward to confirm,
as the basis of the outer induction,
that
$$ \Vesi{Em}{0} \cong \Vesi{M}{0}$$
and that $\Vesi{Em}{0}$ is in Emulation order.

The inner induction is done on the operations to build
the Earley sets for $\var{i}>0$.
The hypothesis for the inner induction is that,
up to this point,
the following three invariants hold:
\begin{center}
\begin{tabular}{l p{1in} p{3.5in}}
1. \hspace{1em} & Congruence &
$\Vesi{EM}{i} \cong \Vesi{M}{i}$ \\
2. & Item Order & \Vesi{EM}{i} is in Emulation Order \\
3. & Operation \mbox{Sequence} &
\Emulator{} in Marpa mode and \Marpa{} carry out the
same basic Earley operations.
\end{tabular}
\end{center}

As the basis of inner induction, we observe
that, trivially, the two empty Earley sets are congruent,
that an empty Earley set is in Emulation order.
To show that the next operations will be the same,
we observe that
that the first basic operation for both recognizers will be
the scan whose predecessor comes first in the 
the previous Earley set,
and that by the outer induction hypothesis,
both previous Earley sets will be in Emulation order.

For the step of the inner induction,
it is convenient to first show that
the Operation Sequence invariant holds.
If we assuming the induction hypothesis
for the inner induction,
we can see,
based on the Emulation Order,
the pseudocode for \Leo
and the pseudocode for \Marpa
that this sequence of basic operations will be
scan operations, then collection operations.
Scan operation will be in order by predecessor,
and collection operations in order by predecessor
within LHS.

By the outer induction hypothesis, 
Earley items of \Emulator{} and \Marpa{}
will be in the same order by AHFA state
for the predecessors.
Based on Emulation Symbol Order and the
inner induction hypothesis,
we know that the two recognizers
will process the collection operations
in the same order by LHS symbol.

The Item Order invariant is straightforward to show.
As long as the inner and outer induction hypotheses
are true,
by their definitions,
\Emulator and \Marpa add all Earley items in
Emulator Order.

To complete the step of the inner induction,
we now proceed to show that Congruence stays invariant
as new Earley items are added.
We do this by cases, where the bases are the basic operations.

For the cases of scanning and Earley collection,
we recall that \Marpa{} and \Emulator{}
both implement the transition logic of AHFA's,
as described in \cite{AH2002}.
We know from the inner and outer induction hypotheses
that they will find congruent predecessors
from congruence that the LHS's of completed rules will be the same,
and from the definition of the recognizer that the tokens will be
the same.
From this we can see that,
for every EIMM added by \Marpa,
as least one EIMX (the base EIMX) will be added
by \Emulator in Marpa mode,
and that the EIMX will have the same AHFA state
as the EIMM.
Therefore, the Earley items added by each scanning
or Earley item operation
will be congruent.
The union of congruent sets of Earley items is also congruent,
so that the Earley sets under construction remain congruent
as items from these operations are added.
This show the case of the Congruence invariant
for scanning and Earley collection operations,
as part of the inner induction step.

To complete the inner induction step,
it remains to show the case of the Congruence invariant
for the Leo collection operation.
By the definition of Leo collection, it
produces a single AHFA state,
call this \Vah{leo-complete}.
By Theorem \ref{t:leo-singleton},
\Vah{collected} will contain one and only one dotted rule,
\Vdr{collected}.
\Vdr{collected} will be a completion.
Since the only rule in the \Vah{collected} is a completion,
\Vah{collected} will have no null-transition.
Therefore
a Leo collection operation
in \Marpa{}
will add only one EIMM, $[\Vah{leo-complete}, \Vloc{origin}]$,
where \Vloc{origin} is from the LIMX.
\Emulator in Marpa mode will add only
those EIMX in the set
$${
[ \Vbool{active}, \Vah{collected}, \Vdr{d}, \Vloc{origin} ]
\sep \Vdr{d} \in \var{null}(\Vdr{collected}) }
$$
Clearly, congruence will hold with the addition to these
Earley items to their respective Earley sets.

The completes the inner induction step, the inner induction,
the outer induction step, the outer induction and the proof.
\end{proof}

\section{Marpa recognizer time complexity}
\label{s:marpa:complexity}

\begin{theorem}\label{t:constant-per-EIM}
All time in \Marpa{} can be allocated
to the Earley items,
and in such a way that processing each Earley item
requires $\order{1}$ time.
\end{theorem}

\begin{proof}
It is known that the time taken by
the traditional Earley recognizer
for its operations
operations can be done in amortized $\order(1)$
time per Earley item~\cite[Vol. 1, pages 326-327]{AU1972}.
Inspection of the algorithm for \Marpa{} will show
that any operations considered to be new to it
can be assigned to the Earley items in
an obivous way,
and 
trivially shown to be $\order{1}$.
\end{proof}

\begin{theorem}
For all context-free grammars,
the time and space complexity
of \Marpa{} is as good or better
than that of Earley's algorithm.
\end{theorem}

\begin{proof}
The time and space complexity
results for $\Earley$ are based
on establishing the order of the number of Earley items,
and showing that $\Earley$ takes
$\order{1}$ time and 
$\order{1}$ space
for each Earley
item.~\cite[Vol. 1, pages 325-327]{AU1972}.
By Theorem \ref{a:eim-order},
for any grammar, the order of the number of Earley
items is the same in \Marpa{} as it is
in $\Earley$.
It is trivial to show that the space requirements for
\Marpa{} are $\order{1}$ time for each Earley item.
By Theorem ref{t:constant-per-EIM},
the time requirements for
\Marpa{} are also $\order{1}$ for each Earley item.
Therefore the time and space complexity results for $\Earley$
hold for \Marpa.
\end{proof}

\begin{theorem}
For all context-free grammars,
the time and space complexity
of \Marpa{} is as good or better
than that of Earley's algorithm.
\end{theorem}

\begin{theorem}
For every LR-regular grammar,
\Marpa{} runs in linear time and linear space.
\end{theorem}

\section{Generalizing the grammar}
\label{s:generalizing}

This section deals with certain modifications
to the
definition of a grammar made by Marpa.
They
are minor from a theoretical point of view,
and their discussion has been deferred so that the
proofs up to this point might more closely follow
tradition.

First, Marpa does not require that $\symset{lh}$
and $\symset{lh}$ be disjoint.
In other words a Marpa symbol may be both a terminal
and a LHS.
This expansion of the grammar definition 
is made without loss of generalization,
or effect on the results so far.

Second, Marpa's input model is a generalization of
the traditional input stream model
used so far.
Marpa's input is a set of tokens,
$toks$,
whose elements are triples of symbol,
start location and end location:
$(\sym{t}, \loc{start}, length)$
such that $\sym{t} \in \symset{lh} \wedge length \ge 1 \wedge \loc{start} \ge 0$.
The size of the input, $\size{toks}$ is the maximum over
$toks$ of $\loc{start}+length$.
Tokens may overlap,
but gaps are not allowed:
$\forall \loc{i} (\exists \token{t} \sep \token{t} \in toks
\wedge t = (\sym{t}, \loc{start}, length)
\wedge \loc{start} \le \loc{i} \le \loc{start}+length$.

The traditional input stream is the special case of
a Marpa input stream where 
$\forall \token{tok} \sep \token{tok} \in toks \implies 
\token{tok} = (\sym{s}, \loc{start}, 1)
$
and
$\forall \token{tok1}, \token{tok2} \in toks \sep
\token{tok1} = (\sym{s1}, \loc{start1}, 1)
\wedge
\token{tok2} = (\sym{s2}, \loc{start2}, 1)
\wedge (\loc{start1} = \loc{start2} \implies \token{tok1} = \token{tok2})
$.

The correctness results hold for Marpa input streams,
but to preserve the time complexity bounds,
certain restriction must be imposed on them.
Call an Earley set, $\es{table[j]}$
a "lookahead set" at $\loc{i}$
if $j>i \wedge$
and there exists some token $\token{tok} = (\sym{s}, \loc{start}, length)$
such that $\loc{start} \le i \wedge \loc{start}+length = \loc{j}$.
If, at every location,
the number of tokens which start there,
and the number of lookahead sets in play at that location
is less than a finite constant,
then Earley items can be added in amortized constant time
and the complexity results for
\Marpa{} stand.

\bibliographystyle{plain}

\begin{thebibliography}{10}

\bibitem{AU1972}
Alfred H.~Aho and Jeffrey D.~Ullman.
\newblock The Theory of Parsing, Translation, and Computing
\newblock Prentice-Hall, Englewood Cliff, N.J., 1972.

\bibitem{AH2002}
John~Aycock and R.~Nigel~Horspool.
\newblock Practical Earley Parsing
\newblock {\em The Computer Journal},
    Vol. 45, No. 6, 2002, pp. 620-630.

\bibitem{Earley1970}
J.~Earley.
\newblock An efficient context-free parsing algorithm.
\newblock {\em Communications of the Association for Computing Machinery},
  13(2):94--102, 1970.

\bibitem{GJ2008}
Dirk~Grune and Ceriel~J.H Jacobs
\newblock {\em Parsing Techniques: A Practical Guide}.
\newblock Springer, Amsterdam, 2008.

\bibitem{Marpa-R2}
Jeffrey~Kegler, 2012: Marpa-R2.
\newblock [ Available online at http://search.cpan.org/dist/Marpa-R2/. ]

\bibitem{Marpa-XS}
Jeffrey~Kegler, 2011: Marpa-XS-1.002000.
\newblock [ Available online at http://search.cpan.org/dist/Marpa-XS/. ]

\bibitem{Leo1991}
J.~M. I.~M. Leo.
\newblock A general context-free parsing algorithm running in linear time on
  every {LR($k$)} grammar without using lookahead.
\newblock {\em Theoretical Computer Science}, 82:165--176, 1991.

\end{thebibliography}
 
\end{document}

# Copyright 2012 Jeffrey Kegler
# This file is part of Marpa::R2.  Marpa::R2 is free software: you can
# redistribute it and/or modify it under the terms of the GNU Lesser
# General Public License as published by the Free Software Foundation,
# either version 3 of the License, or (at your option) any later version.
#
# Marpa::R2 is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser
# General Public License along with Marpa::R2.  If not, see
# http://www.gnu.org/licenses/.

=head1 Name

Marpa::R2::Scanless - Scanless interface

=head1 This document is UNDER CONSTRUCTION

=head1 About this document

This document is an introduction to Marpa's Scanless interface.
It introduces the concepts behind the interface.
The reference documentation for the
scanless interface is in two separate documents,
L<one dealing with scanless grammar objects|Marpa::R2::Scanless::G>
and
L<one dealing with scanless recognizer objects|Marpa::R2::Scanless::R>.

=head1 The two levels of language description

There are two levels at which programmers
describe the syntax of their languages.
This two-level approach is convenient for some
implementation strategies.
But it also seems to be a natural approach to
language design issues.

The first level is structural.
For example, the Perl docs describe one of the forms that Perl's C<use> statement takes
in this way

    use Module VERSION LIST

and in Perl's source code (C<perly.y>) something similar
drives the parser.

The second level is lexical.
For example,
Perl's L<perlpodspec> page has a number of statements like this:

    [...] you can distinguish URL-links from anything else
    by the fact that they match m/\A\w+:[^:\s]\S*\z/.

The lexical level is character by character.
The structural level is less well-defined,
but in practice it ignores most of the character-by-character issues,
and it almost always avoids dealing with whitespace.

For reasons that will become clear later,
I will sometimes call the lexical level, G0,
and will sometimes call the structural level, G1.
It is important to realize
that the difference between G0 and G1 is one
of level of descripton and
NOT one of precision or exactness.
Something similar to the
structural description of Perl's C<use> statement,
which I just cited,
in its source code (C<perly.y>),
along with many other structural-level descriptions of
the language,
and it is these that are used
generate the production parser for Perl.
Clearly structural level descriptions can be every bit
as much a precision instrument as regular expressions.

=head1 A very simple language

In order to focus on very basic issues,
I will use as an example,
an very simple language with a very simple semantics.
The language consists of decimal digits and ASCII spaces.
The semantics will treat it as a series of integers to be added.

Here are three strings in that language

     8675311
     867 5311
     8 6 7 5 3 1 1

According to our semantics,
the three string contain respectively,
one, two and seven integers.
The values of the three strings are,
according to our semantics,
the sum of these integers:
respectively, 8675311, 6178, and 31.

It's often said, in describing languages like the above,
that "whitespace is ignored".
From the purely structural point of view this can be, in one sense, true.
But from the lexical point of view it's clearly quite false.

Combining the two levels of description,
it is very hard to justify an assertion that "whitespace is ignored".
The three strings in the display above
differ only in whitespace.
Clearly the placement
of the whitespace makes a vast difference, and has a major
effect on the structure of string,
which in turn has a determining effect on its semantics.

=head1 Why the structural level?

As we've seen, the structural level ignores essential aspects
of the language.
It is possible to describe a language using a single level of description.
So why have a structural (G1) level of description?

A hint as to why is provided by the widespread use of structural level,
not just in standards, but also in code like the Perl parser.
Try, as as exercise, to rewrite a complex grammar, taking
into account whitespace.
If you know C, a good example will be C declarations.

    unsigned int a;
    unsigned*b;

In the first of the two lines above the whitespace is necessary.
In the second of the two lines whitespace would be allowed,
but is not necessary.
You cannot simply insist on whitespace between all symbols,
because whitespace is and should be optional between
some symbols and not between others.
Where whitespace is optional, and where it should not be,
depends on the initial and final characters,
and this information is not convenient to represent
at the structural (G1) level.
If you try to represent this,
the size of the grammar grows rapidly,
and the number of special cases even more rapidly.

As the description becomes harder and harder to write,
there becomes less and less point in doing so --
it rapidly gets to the point where nobody could read and
understand it.
This is why languages are usually written in a G1, structural level description,
leaving aside most lexical and whitespace issues.
And this is the case even description is used
for generating production code.

=head1 The scanless interface's solution

Here is full syntax of
the example whitespace-and-digit language,
described using Marpa::R2's scanless interface:

=for Marpa::R2::Display
name: Scanless concept example
partial: 1
normalize-whitespace: 1

    :start ::= <number sequence>
    <number sequence> ::= <number>+ action => add_sequence
    number ~ digit+
    digit ~ [0-9]

    :discard ~ whitespace
    whitespace ~ [\s]+

=for Marpa::R2::Display::End

This document is intended for readers already familiar with
Marpa::R2's BNF (Stuifzand) interface.
In this example, three of the scanless interface's extensions
to the Stuifzand interface are used.
First, the tilde ("C<~>") is used to separate LHS and RHS of rules at the lexical
(G0) level.
Rules whose LHS and RHS are separated by the traditional BNF operator ("C<::=>")
are at the structural (G1) level.

Second, Perl character classes are now allowed on the RHS of prioritized and quantified
rules.
The example shows character classes only in G0 rules,
but character classes can also be used in G1 rules.
When a character class is used
in a G1 rule, it still must be implemented at
the G0 level.
Marpa knows this and "does what you mean."

Third, a new type of rule is introduced:
a "discard" rule.
A discard rule has a C<:discard> pseudo-symbol on its LHS
and one symbol name on its RHS.
It indicates that, when the RHS symbol is recognized,
it should not be passed on as usual to the structural (G1) level.
Instead, the lexical (G0) level will simply "discard" what it has
found.
In the example, whitespace is discarded.

=head1 Copyright and License

=for Marpa::R2::Display
ignore: 1

  Copyright 2012 Jeffrey Kegler
  This file is part of Marpa::R2.  Marpa::R2 is free software: you can
  redistribute it and/or modify it under the terms of the GNU Lesser
  General Public License as published by the Free Software Foundation,
  either version 3 of the License, or (at your option) any later version.

  Marpa::R2 is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser
  General Public License along with Marpa::R2.  If not, see
  http://www.gnu.org/licenses/.

=for Marpa::R2::Display::End

=cut

# Local Variables:
#   mode: cperl
#   cperl-indent-level: 4
#   fill-column: 100
# End:
# vim: expandtab shiftwidth=4:


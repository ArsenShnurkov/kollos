# Copyright 2012 Jeffrey Kegler
# This file is part of Marpa::R2.  Marpa::R2 is free software: you can
# redistribute it and/or modify it under the terms of the GNU Lesser
# General Public License as published by the Free Software Foundation,
# either version 3 of the License, or (at your option) any later version.
#
# Marpa::R2 is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser
# General Public License along with Marpa::R2.  If not, see
# http://www.gnu.org/licenses/.

=head1 NAME

Marpa::R2::Advanced::Thin - Direct access to Libmarpa

=head1 About this document

At this moment, this document is INCOMPLETE and,
for that reason
NOT 100% RELIABLE.

Most Marpa users can ignore this document.
It describes Marpa's "thin" interface.
The provides efficient access to Marpa's core
library, Libmarpa.
It provides the ultimate in Marpa speed,
power and flexibility.

The "thin" interface is very low-level and
NOT convenient to use --
user-friendliness is expected to be provided by
an upper layer.
The "thin" interface is intended for those writing
upper layers for Marpa.
It is also for those writing applications,
when they want
to eliminate the overhead of an upper layer,
or when they want the flexibility provided by direct access to Libmarpa.

This document assumes that the reader is familiar with
the other Marpa::R2 documentation,
as well as the Libmarpa API document.
This means the reader will have to know some C language,
enough to understand C function prototypes.

=head1 How this document is written

The Libmarpa interface is described in the Libmarpa
API document,
and this document avoids duplicating the material there.
This document states general rules for the "thin" interface.
Methods that do not
depart from the general rules
are not specifically mentioned.

While this style and level of documentation 
is efficient,
and the standard for C library interfaces to Perl,
it is,
admittedly, very terse.
As an aid to
the reader,
an example of the usage of the thin interface is presented
L<below|"Example">.
While small, the example is non-trival.
It includes a full
logic flow, starting with the definition
of the grammar
and contining all the way to the iteration of
the values of an ambiguous parse.

=head1 Methods in the thin interface

As of this writing, the thin interface has
no methods of its own.
Each of its methods is a wrapper for a method
from the Libmarpa interface.

Not all Libmarpa methods have thin interface wrappers.
None of Libmarpa's internal methods are included in
the thin interface.
Additionally, some of Libmarpa's external methods
provide services that are handled internally by the thin
interface,
and wrappers to those methods
are therefore not included in the actual interface.
When an external Libmarpa method is omitted,
this will be specificially stated,
with the reason for the omission.

Whenever an external Libmarpa method is not mentioned
in this document, the reader can assume that
it has a wrapper that is implemented according
to the general guidelines, as
given below.
Where the implementation of an
external libmarpa methods
is an exception to the guidelines,
or has other peculiarities,
that will be explicitly stated.

=head1 Libmarpa time classes

As a reminder,
the classes of
Libmarpa's time objects are,
in sequence,
grammar, recognizer, bocage,
ordering, tree and value.
The one-letter abbreviations for these
are, respectively,
C<g>, C<r>, C<b>, C<o>, C<t> and C<v>.

Internal Libmarpa methods have names of the form
C<marpa_g_start_symbol_set>.
The name always begin with the six-letter prefix
C<marpa_>.
Next follows a single letter and an underscore.
The one-letter is one of Libmarpa's time class
abbreviations, and indicates which
class the method belongs to.
(At this writing, there is no Libmarpa static
method in the thin interface.)
In the thin interface,
The corresponding Perl closure would be named
C<start_symbol_set> and would be a method of the
class C<Marpa::R2::Thin:G>.

The Libmarpa C prototypes always take the appropriate class object
as their first argument.
Zero or more other arguments follow this first time class argument.
In Perl, the thin interface wrapper would called as a class method,
and the second and subsequent arguments of the C function would
be the arguments to the Perl method closure.

As an example, here is a call to a Libmarpa function

=for Marpa::R2::Display
ignore: 1

  marpa_g_start_symbol_set (grammar, symbol_S);

=for Marpa::R2::Display::End

This is a corresonding call in the thin interface:

=for Marpa::R2::Display
name: Thin example
normalize-whitespace: 1
partial: 1

    $grammar->start_symbol_set($symbol_S);

=for Marpa::R2::Display::End

So far, we have not explained the
translation between the C language
arguments and return values and those in Perl.
This will be described below.

=head1 Methods omitted

No internal Libmarpa method is part of the thin interface.
The C<marpa_check_version()> static method is not
part of the thin interface, because the thin interface
interface handles its own version matching.

The thin interface deals with all reference counting
issues, and interconnects Libmarpa's reference counting
with Perl's.  The application can rely on Libmarpa
objects being cleaned up properly as part of Perl's
ordinary garbage collection.
For this reason, there are no thin wrappers for the 
C<mapra_g_ref()>, C<mapra_g_unref()>,
C<mapra_r_ref()>, C<mapra_r_unref()>,
C<mapra_b_ref()>, C<mapra_b_unref()>,
C<mapra_o_ref()>, C<mapra_o_unref()>,
C<mapra_t_ref()>, C<mapra_t_unref()>
C<mapra_v_ref()>, and C<mapra_v_unref()> methods.

=head1 Libmarpa time objects and constructors

The thin interface implements a Perl class
for each of the Libmarpa time classes.
These Perl classes should be considered opaque.
The only operations an application should perform
on objects blessed into the thin interfaces
classes is to assign them,
and to use them to call methods in their class.
Their namespace should be left strictly alone.
In particular,
new objects and methods
should not be defined in it
and they should not be subclassed.

=for Marpa::R2::Display
ignore: 1

    Marpa_Grammar       Marpa::R2::Thin::G
    Marpa_Recognizer    Marpa::R2::Thin::R
    Marpa_Bocage        Marpa::R2::Thin::B
    Marpa_Ordering      Marpa::R2::Thin::O
    Marpa_Tree          Marpa::R2::Thin::T
    Marpa_Value         Marpa::R2::Thin::V

=for Marpa::R2::Display::End

Constructors for the time objects may be called using
the C<new> method of the corresponding Perl class.
For example,

=for Marpa::R2::Display
name: Thin example
partial: 1
normalize-whitespace: 1

    my $recce = Marpa::R2::Thin::R->new($grammar);

=for Marpa::R2::Display::End

For destruction, the thin interface's time objects
behave like other Perl objects.
The thin interface takes care of Libmarpa's reference
counting for the user.

=head1 Errors

In general,
when a Libmarpa method returns -1 to indicate failure,
the thin interface return a Perl C<undef>.
When a Libmarpa method returns -2 to indicate failure,
the thin interface throws a Perl exception.

The thin interface allows a Perl application to
interrogate the Libmarpa error codes
and descriptions.
The thin interfaces error methods differ from
those of Libmarpa.

=for Marpa::R2::Display
name: Thin grammar error methods

$error_code = $grammar->error_code();
$error_description = $grammar->error();

=for Marpa::R2::Display::End

The C<error_code()> method returns the error code.
The error code is a string:
the error code macro, as listed in
the Libmarpa documentation.
Once Libmarpa is out of alpha,
this can be relied on by application to be stable.
Originally it would have been a mnemonic describing
the error, but the programmer should not rely on this.

The C<error()> method returns a message describing the 
the error code.

=for Marpa::R2::Display
name: Thin recognizer error methods

my $error_code = $recce->error_code();
my $error_description = $recce->error();

=for Marpa::R2::Display::End

=head1 Grammar methods

=head2 Constructor

=for Marpa::R2::Display
name: Thin example
partial: 1
normalize-whitespace: 1

    my $grammar  = Marpa::R2::Thin::G->new();

=for Marpa::R2::Display::End

Because version checking is handled by the thin interface internally,
the grammar constructor does NOT accept the version numbers as arguments.
There are no arguments to the grammar constructor.
Its return value is a thin interface grammar object.
An exception is thrown if there is a version mismatch, which should
not happen -- it indicates a problem with the way that the library
was built.

=head1 Example

=for Marpa::R2::Display
name: Thin example
normalize-whitespace: 1

    my $grammar  = Marpa::R2::Thin::G->new();
    my $symbol_S = $grammar->symbol_new();
    my $symbol_E = $grammar->symbol_new();
    $grammar->start_symbol_set($symbol_S);
    my $symbol_op     = $grammar->symbol_new();
    my $symbol_number = $grammar->symbol_new();
    my $start_rule_id = $grammar->rule_new( $symbol_S, [$symbol_E] );
    my $op_rule_id =
        $grammar->rule_new( $symbol_E, [ $symbol_E, $symbol_op, $symbol_E ] );
    my $number_rule_id = $grammar->rule_new( $symbol_E, [$symbol_number] );
    $grammar->precompute();

    my $recce = Marpa::R2::Thin::R->new($grammar);
    $recce->start_input();

    # The numbers from 1 to 3 are themselves --
    # that is, they index their own token value.
    # Important: zero cannot be itself!

    my @token_values         = ( 0 .. 3 );
    my $zero                 = -1 + +push @token_values, 0;
    my $minus_token_value    = -1 + push @token_values, q{-};
    my $plus_token_value     = -1 + push @token_values, q{+};
    my $multiply_token_value = -1 + push @token_values, q{*};

    $recce->alternative( $symbol_number, 2, 1 );
    $recce->earleme_complete();
    $recce->alternative( $symbol_op, $minus_token_value, 1 );
    $recce->earleme_complete();
    $recce->alternative( $symbol_number, $zero, 1 );
    $recce->earleme_complete();
    $recce->alternative( $symbol_op, $multiply_token_value, 1 );
    $recce->earleme_complete();
    $recce->alternative( $symbol_number, 3, 1 );
    $recce->earleme_complete();
    $recce->alternative( $symbol_op, $plus_token_value, 1 );
    $recce->earleme_complete();
    $recce->alternative( $symbol_number, 1, 1 );
    $recce->earleme_complete();

    my $latest_earley_set_ID = $recce->latest_earley_set();
    my $bocage        = Marpa::R2::Thin::B->new( $recce, $latest_earley_set_ID );
    my $order         = Marpa::R2::Thin::O->new($bocage);
    my $tree          = Marpa::R2::Thin::T->new($order);
    my @actual_values = ();
    while ( $tree->next() ) {
        my $valuator = Marpa::R2::Thin::V->new($tree);
        $valuator->rule_is_valued_set( $op_rule_id,     1 );
        $valuator->rule_is_valued_set( $start_rule_id,  1 );
        $valuator->rule_is_valued_set( $number_rule_id, 1 );
        my @stack = ();
        STEP: while ( my ( $type, @step_data ) = $valuator->step() ) {
            last STEP if not defined $type;
            if ( $type eq 'MARPA_STEP_TOKEN' ) {
                my ( undef, $token_value_ix, $arg_n ) = @step_data;
                $stack[$arg_n] = $token_values[$token_value_ix];
                next STEP;
            }
            if ( $type eq 'MARPA_STEP_RULE' ) {
                my ( $rule_id, $arg_0, $arg_n ) = @step_data;
                if ( $rule_id == $start_rule_id ) {
                    my ( $string, $value ) = @{ $stack[$arg_n] };
                    $stack[$arg_0] = "$string == $value";
                    next STEP;
                }
                if ( $rule_id == $number_rule_id ) {
                    my $number = $stack[$arg_0];
                    $stack[$arg_0] = [ $number, $number ];
                    next STEP;
                }
                if ( $rule_id == $op_rule_id ) {
                    my $op = $stack[ $arg_0 + 1 ];
                    my ( $right_string, $right_value ) = @{ $stack[$arg_n] };
                    my ( $left_string,  $left_value )  = @{ $stack[$arg_0] };
                    my $value;
                    my $text = '(' . $left_string . $op . $right_string . ')';
                    if ( $op eq q{+} ) {
                        $stack[$arg_0] = [ $text, $left_value + $right_value ];
                        next STEP;
                    }
                    if ( $op eq q{-} ) {
                        $stack[$arg_0] = [ $text, $left_value - $right_value ];
                        next STEP;
                    }
                    if ( $op eq q{*} ) {
                        $stack[$arg_0] = [ $text, $left_value * $right_value ];
                        next STEP;
                    }
                    die "Unknown op: $op";
                } ## end if ( $rule_id == $op_rule_id )
                die "Unknown rule $rule_id";
            } ## end if ( $type eq 'MARPA_STEP_RULE' )
            die "Unexpected step type: $type";
        } ## end while ( my ( $type, @step_data ) = $valuator->step() )
        push @actual_values, $stack[0];
    } ## end while ( $tree->next() )

=for Marpa::R2::Display::End

=head1 Copyright and License

=for Marpa::R2::Display
ignore: 1

  Copyright 2012 Jeffrey Kegler
  This file is part of Marpa::R2.  Marpa::R2 is free software: you can
  redistribute it and/or modify it under the terms of the GNU Lesser
  General Public License as published by the Free Software Foundation,
  either version 3 of the License, or (at your option) any later version.

  Marpa::R2 is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser
  General Public License along with Marpa::R2.  If not, see
  http://www.gnu.org/licenses/.

=for Marpa::R2::Display::End

=cut

# Local Variables:
#   mode: cperl
#   cperl-indent-level: 4
#   fill-column: 100
# End:
# vim: expandtab shiftwidth=4:

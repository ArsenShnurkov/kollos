# Copyright 2013 Jeffrey Kegler
# This file is part of Marpa::R2.  Marpa::R2 is free software: you can
# redistribute it and/or modify it under the terms of the GNU Lesser
# General Public License as published by the Free Software Foundation,
# either version 3 of the License, or (at your option) any later version.
#
# Marpa::R2 is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser
# General Public License along with Marpa::R2.  If not, see
# http://www.gnu.org/licenses/.

=head1 Name

Marpa::R2::Scanless::R - Scanless interface recognizers

=head1 Synopsis

=for Marpa::R2::Display
name: Scanless recognizer synopsis
partial: 1
normalize-whitespace: 1

    my $recce = Marpa::R2::Scanless::R->new( { grammar => $grammar } );
    my $self = bless { grammar => $grammar }, 'My_Actions';
    $self->{recce} = $recce;
    local $My_Actions::SELF = $self;

    if ( not defined eval { $recce->read($p_input_string); 1 }
        )
    {
        ## Add last expression found, and rethrow
        my $eval_error = $EVAL_ERROR;
        chomp $eval_error;
        die $self->show_last_expression(), "\n", $eval_error, "\n";
    } ## end if ( not defined eval { $event_count = $recce->read...})

    my $value_ref = $recce->value();
    if ( not defined $value_ref ) {
        die $self->show_last_expression(), "\n",
            "No parse was found, after reading the entire input\n";
    }

=for Marpa::R2::Display::End

=for Marpa::R2::Display
name: Scanless recognizer semantics
partial: 1
normalize-whitespace: 1

    package My_Actions;

    our $SELF;
    sub new { return $SELF }

    sub do_parens    { shift; return $_[1] }
    sub do_add       { shift; return $_[0] + $_[2] }
    sub do_subtract  { shift; return $_[0] - $_[2] }
    sub do_multiply  { shift; return $_[0] * $_[2] }
    sub do_divide    { shift; return $_[0] / $_[2] }
    sub do_pow       { shift; return $_[0]**$_[2] }
    sub do_first_arg { shift; return shift; }
    sub do_script    { shift; return join q{ }, @_ }

=for Marpa::R2::Display::End

=for Marpa::R2::Display
name: Scanless recognizer diagnostics
partial: 1
normalize-whitespace: 1

    sub show_last_expression {
        my ($self) = @_;
        my $recce = $self->{recce};
        my ( $g1_start, $g1_length ) = $recce->last_completed('Expression');
        return 'No expression was successfully parsed' if not defined $g1_start;
        my $last_expression = $recce->substring( $g1_start, $g1_length );
        return "Last expression successfully parsed was: $last_expression";
    } ## end sub show_last_expression

=for Marpa::R2::Display::End

=head1 About this document

This page is the reference document for the recognizer objects
of Marpa's Scanless interface.

=head1 Locations

=head2 Input stream locations

In this document, the word "location" refers
to location in the input stream,
unless otherwise specified.

=head2 Negative locations

Several methods allow locations and lengths to be specified
as negative numbers.
A negative location is a location counted
from the end, so that -1 means the
last location of the string,
-2 the second to last location, etc.
A negative length assumes that a start location
has been specified and indicates a distance to a location
counted from the end.
A length of -1 indicates the distance to the end of the string,
-2 indicates the distance to the character just before the
end of the string,
etc.

For example, suppose that we are dealing with input stream locations.
The span "C<-1, -1>" indicates the substring consisting
of the last character of input stream.
the span "C<-2, -1>" indicates the substring consisting
of the last two characters of the input stream.
The span "C<-2, 1>" indicates the substring consisting
of the second to last character of the input stream.

=head2 G1 locations

This section on trace methods often 
describes location in terms of 
G1 Earley sets.
There are B<not> input stream locations.
G1 Earley set location
is more often called simply G1 location.

G1 length is length in Earley sets.
For a G1 span, its
G1 end location will
always be the G1 start location plus the G1 length.

There is no method to convert G1 location to
input stream locations --
because Marpa allows scanning to retrace sections of
the input stream, G1 locations do not necessarily translate
to locations in the input stream.

=head1 Constructor

=for Marpa::R2::Display
name: Scanless recognizer synopsis
partial: 1
normalize-whitespace: 1

    my $recce = Marpa::R2::Scanless::R->new( { grammar => $grammar } );

=for Marpa::R2::Display::End

The C<new()> method is the constructor for Scanless recognizers.
An example of its use is L<above|/"Synopsis">.
The C<new()> constructor accepts a hash of named arguments.
The following named arguments are allowed:

=head2 grammar

The C<new> method is required to have
a C<grammar> named argument.  Its
value must be
a Scanless grammar object.

=head2 too_many_earley_items

The C<too_many_earley_items> argument is optional,
and very few applications will need it.
If specified, it sets the B<Earley item warning threshold> to
a value other than its default.
If an Earley set becomes larger than the
Earley item warning threshold,
a recognizer event is generated,
and
a warning is printed to the trace file handle.

Marpa parses from any BNF,
and can handle grammars and inputs which produce large
Earley sets.
But parsing that involves large Earley sets can be slow.
Large Earley sets
are something most applications can,
and will wish to, avoid.

By default, Marpa calculates
an Earley item warning threshold
for the G1 recognizer
based on the size of the
G1 grammar,
and for each G0 recognizer based on the size
of the G0 grammar.
If the
Earley item warning threshold is changed from its default,
the change applies to both G0 and G1 -- currently
there is no way to set them separately.

The default threshold will never be less than 100.
If the Earley item warning threshold is set to 0,
no recognizer event is generated,
and
warnings about large Earley sets are turned off.

=head2 trace_terminals

If non-zero, traces the lexemes --
those tokens passed from the G0 parser to
the G1 parser.
This named argument is the best way to follow
what the G0 parser is doing,
but it is also very helpful for tracing the G1 parser.

=head2 trace_values

This named argument is passed on
to the G1 recognizer.
See L<Marpa::R2::Recognizer/"trace_values">

=head2 trace_file_handle

The value is a file handle.
Trace output and warning messages
go to the trace file handle.
By default the trace file handle is C<STDERR>.

=head1 Basic mutators

=head2 read()

=for Marpa::R2::Display
name: Scanless recognizer synopsis
partial: 1
normalize-whitespace: 1

    $recce->read($p_input_string);

=for Marpa::R2::Display::End

=for Marpa::R2::Display
name: SLIF external read example
partial: 1
normalize-whitespace: 1

    $recce->read(\$string, 0, 0);

=for Marpa::R2::Display::End

Given a pointer to an input string,
parses it according to the grammar.
Only a single call to C<read()>
is allowed for a scanless
recognizer.

C<read()> recognizes
optional second and third arguments.
The second argument is a location in the input string
at which internal scanning will start.
The third argument is the length of the section
of the input string to be scanned before pausing.
The default start location is zero.
The default length is -1.
Negative locations and lengths have the standard
interpretation, as L<described above|/"Negative locations">.

One important case is where start location and length
are both specified as zero.
This pauses internal scanning immediately and can be
used to hand control over completely to an external
scanner.

On failure, throws an exception.
The call is considered successful
if it ended because a parse was found,
or because internal scanning was paused.
On success, C<read()> returns the location in the input
string before which internal scanning ended.
This value may be zero.

=head2 value()

=for Marpa::R2::Display
name: Scanless recognizer synopsis
partial: 1
normalize-whitespace: 1

    my $value_ref = $recce->value();

=for Marpa::R2::Display::End

Has the same effect as a C<value()> call
on the G1 recognizer.
See L<Marpa::R2::Recognizer/"value()">.

=head1 Mutators for external scanning

=head2 lexeme_alternative()

=for Marpa::R2::Display
name: SLIF lexeme_alternative() example
partial: 1
normalize-whitespace: 1

            if ( not defined $recce->lexeme_alternative($token_name) ) {
                die
                    qq{Parser rejected token "$long_name" at position $start_of_lexeme, before "},
                    substr( $string, $start_of_lexeme, 40 ), q{"};
            }

=for Marpa::R2::Display::End

The C<lexeme_alternative()> method
allows an external scanner to read
ambiguous tokens.
Most applications 
will prefer the simple lexeme_read().

C<lexeme_alternative()> takes one or two argument.
The first, required, argument is the name of a symbol to be read
at the current location.
The second, optional, argument is the value of the symbol.

Any number of tokens may be read using C<lexeme_alternative()>
without advancing the current location.
This allows an application to use ambiguous tokens.
To complete the reading at a location,
and advance the current location to the next location,
use the C<lexeme_complete()> method.

If the value argument is omitted,
the token's value will a string
which contains the corresponding substring
of the input stream.
(The token's location in the input stream will be set
by the lexeme_complete() method.)
Omitting the value argument does not have the same
effect as passing an explicit Perl C<undef>.
If the second argument is an explicit Perl C<undef>,
the value of the lexeme will be a Perl C<undef>.

On success, returns a non-negative number.
Returns undef if the token was rejected.
Failures are thrown as exceptions.

=head2 lexeme_complete()

=for Marpa::R2::Display
name: SLIF lexeme_alternative() example
partial: 1
normalize-whitespace: 1

            next TOKEN
                if $recce->lexeme_complete( $start_of_lexeme,
                        ( length $lexeme ) );

=for Marpa::R2::Display::End

The C<lexeme_alternative()> allows an external scanner to read
ambiguous tokens.
Most applications will prefer the simple lexeme_read().

The C<lexeme_complete()>
requires two arguments,
a input stream start location and a length.
Negative values are allowed and are interpreted
as L<described above|/"Negative locations">.
This span will be treated as the section of the input stream
that corresponds to the tokens read at the current location.
This correspondence may be artificial, but a span must
always be specified.

The C<lexeme_complete()>
method completes the reading of
alternative tokens at the current location,
and advances the current location by one.
The location of the tokens in the input stream will be as
indicated by 

=head2 lexeme_read()

=head2 resume()

=head1 Accessors

=head2 line_column()

=head2 literal()

=head2 pause_lexeme()

=head2 pause_span()

=head1 Trace methods

=head2 last_completed()

=for Marpa::R2::Display
name: Scanless recognizer diagnostics
partial: 1
normalize-whitespace: 1

    my ( $g1_start, $g1_length ) = $recce->last_completed('Expression');

=for Marpa::R2::Display::End

Given the name of a symbol,
returns the start G1 location and
G1 length of the most recent match.
If there was more than one most recent match, it returns
the longest.
If there was no match, returns the empty array in array context
and a Perl false in scalar context.

=head2 last_completed_range()

Use of this method is discouraged in favor of 
L</"last_completed()">.
Given the name of a symbol,
returns the G1 start and G1 end locations of most recent match.
If there was more than one most recent match, it returns
the longest.
If there was no match, returns the empty array in array context
and a Perl false in scalar context.

=head2 range_to_string()

Use of this method is discouraged in favor of 
L</"substring()">.
Given a G1 start and a G1 end location, returns the substring of the input
string that is between the two.

=head2 show_progress()

=for Marpa::R2::Display
name: Scanless show_progress() synopsis
partial: 1
normalize-whitespace: 1

    my $show_progress_output = $recce->show_progress();

=for Marpa::R2::Display::End

Has the same effect as a C<show_progress()> call
on the G1 recognizer.
See L<Marpa::R2::Recognizer/"show_progress()">.
If location is specified, it must be specified
in terms of G1 location.

=head2 substring()

=for Marpa::R2::Display
name: Scanless recognizer diagnostics
partial: 1
normalize-whitespace: 1

    my $last_expression = $recce->substring( $g1_start, $g1_length );

=for Marpa::R2::Display::End

Given a G1 start location and its G1 length, returns a substring of the input
string.
A length of zero will produce a zero-length string.

=head1 Copyright and License

=for Marpa::R2::Display
ignore: 1

  Copyright 2013 Jeffrey Kegler
  This file is part of Marpa::R2.  Marpa::R2 is free software: you can
  redistribute it and/or modify it under the terms of the GNU Lesser
  General Public License as published by the Free Software Foundation,
  either version 3 of the License, or (at your option) any later version.

  Marpa::R2 is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser
  General Public License along with Marpa::R2.  If not, see
  http://www.gnu.org/licenses/.

=for Marpa::R2::Display::End

=cut

# Local Variables:
#   mode: cperl
#   cperl-indent-level: 4
#   fill-column: 100
# End:
# vim: expandtab shiftwidth=4:


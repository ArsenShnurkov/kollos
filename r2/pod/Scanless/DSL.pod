# Copyright 2013 Jeffrey Kegler
# This file is part of Marpa::R2.  Marpa::R2 is free software: you can
# redistribute it and/or modify it under the terms of the GNU Lesser
# General Public License as published by the Free Software Foundation,
# either version 3 of the License, or (at your option) any later version.
#
# Marpa::R2 is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser
# General Public License along with Marpa::R2.  If not, see
# http://www.gnu.org/licenses/.

=head1 Name

Marpa::R2::Scanless::DSL - The DSL for the Scanless interface

=head1 Synopsis

=for Marpa::R2::Display
name: Scanless grammar synopsis
partial: 1
normalize-whitespace: 1

    my $grammar = Marpa::R2::Scanless::G->new(
        {   
            action_object  => 'My_Actions',
            default_action => 'do_first_arg',
            source          => \(<<'END_OF_SOURCE'),
    :start ::= Script
    Script ::= Expression+ separator => comma action => do_script
    comma ~ [,]
    Expression ::=
        Number
        | '(' Expression ')' action => do_parens assoc => group
       || Expression '**' Expression action => do_pow assoc => right
       || Expression '*' Expression action => do_multiply
        | Expression '/' Expression action => do_divide
       || Expression '+' Expression action => do_add
        | Expression '-' Expression action => do_subtract
    Number ~ [\d]+

    :discard ~ whitespace
    whitespace ~ [\s]+
    # allow comments
    :discard ~ <hash comment>
    <hash comment> ~ <terminated hash comment> | <unterminated
       final hash comment>
    <terminated hash comment> ~ '#' <hash comment body> <vertical space char>
    <unterminated final hash comment> ~ '#' <hash comment body>
    <hash comment body> ~ <hash comment char>*
    <vertical space char> ~ [\x{A}\x{B}\x{C}\x{D}\x{2028}\x{2029}]
    <hash comment char> ~ [^\x{A}\x{B}\x{C}\x{D}\x{2028}\x{2029}]
    END_OF_SOURCE
        }
    );

=for Marpa::R2::Display::End

=head1 About this document

This page is the reference for domain-specific language at
the center
of Marpa's Scanless interface (SLIF).

The format of
Scanless source strings is
L<that of
BNF source strings|Marpa::R2::BNF>,
with the following changes
and extensions:

=head1 Structural rule

The BNF operator ("C<::=>")
has the same function as before,
but in addition it indicates that the rule is
a G1 rule.
Start rules must be G1 rules.

=head1 Lexical rule

The match operator ("C<~>")
can be used between the LHS and RHS of a rule,
instead of the BNF operator.
Rules which use the match operator are G0 rules.
Discard rules must be G0 rules.
A lexical rule cannot have an C<action> adverb.

=head1 Default pseudo-rule

=head1 Lexeme default statement

The lexeme default statement is a "statement",
instead of a "rule".
Rules
are signified by the BNF operator ("C<::=>")
or the match operator ("C<~>"),
and their effect depends on their
lexical position.
Statements
are signified by the assignment operator ("C<=>"),
and their effect is global.
The effect of a statement does not
depend on where in the source file it occurs.

Only one lexeme default statement is allowed in a file.

=head1 C<action> adverb

=head1 Word actions

If the action value is a
a Perl word (a string of alphanumerics or underscores),
it will be interpreted as the action name,
as described for
L<the C<action> named argument of rule descriptors|Marpa::R2::Grammar/"action">.
A rule with a word action is allowed to have a bless adverb,
but as of this writing the blessing will have no effect.

=head1 Reserved actions

If the action value begins with a double colon ("C<::>"),
it is a reserved word action.
For rules, the following are recognized:

=over 4

=item * C<::array>

The value of the semantics is an array containing the
values of each of its children.
If the rule has no children, the array will be empty.

=item * C<::dwim>

This is the "do what I mean action".
The intent is to create an AST
structure that avoids trivial and useless nodes,
but that is also convenient to traverse and evaluate.
The C<::dwim> action
is equivalent to one of the other reserved word actions,
as determined by applying the following criteria, in sequence:

=over 4

=item *

If the rule is blessed, C<::dwim> is equivalent to C<::array>.

=item *

If the rule is a sequence rule, C<::dwim> is equivalent to C<::array>.

=item *

If the rule has two or more children, C<::dwim> is equivalent to C<::array>.

=item *

If the rule has one child, C<::dwim> is equivalent to C<::first>.

=item *

If the rule has no children, C<::dwim> is equivalent to C<::undef>.

=back 

=item * C<::first>

The value of the semantics is that of the rule's first child.
If there is no such child, the value is a Perl C<undef>.
It is a fatal error if a bless action
is applied to a rule with a C<::first> action.
This is the case even when either or both adverbs are
the result of a default.

=item * C<::undef>

The value of the semantics is 
a Perl C<undef>.
It is a fatal error if a bless action
is applied to a rule with a C<::undef> action.
This is the case even when either or both adverbs are
the result of a default.

=back

=head2 Array descriptor actions

C<[range,values]>

=head1 C<bless> adverb

The C<bless> adverb causes the result of the semantics to be
blessed into the class indicated by the value of the adverb.
with being blessed.
C<bless> adverb causes the result of the semantics to be

If the value begins with a double colon ("C<::>"), it is a
reserved value.
The bless adverb for
rules allows only one reserved value: C<::lhs>.
A reserved value of C<::lhs> causes the result to be blessed into
a class named based on the LHS of the rule.
The class will be the name of the LHS with whitespace (as already
normalized for the symbol name) changed to an underscore.
When a C<::lhs> bless value applies to a rule, it is a fatal
error if the LHS contains anything other than an alphanumeric
or whitespace.
In particular, the LHS cannot already contain an underscore ("C<_>").

The bless adverb for lexemes allows only one
reserved value: C<::name>.
A reserved value of C<::name> causes the result to be blessed into
a class named based on the name of the rule.
The class is derived from the symbol name in the same way,
and subject to the same restrictions,
as described above for deriving a class name from the LHS
of a rule.

=head1 Discard rules

A discard rule is a rule whose LHS is
the C<:discard> pseudo-symbol,
and whose RHS is a single symbol name,
called the B<discarded symbol>.
These rules indicate that the discarded symbol is a top-level G0
symbol, but one which is not a lexeme.
When a discarded symbol is recognized,
it is not passed as a lexeme to the G1 parser, but is
(as the name suggests) discarded.

=head1 Single quoted strings

Single quotes can be used in prioritized
rules to indicate character strings.
The characters inside the single quote
will be matched in the input, literally and one-for-one.
Single quoted strings can contain any characters with
the exception of
single quotes and vertical whitespace.

Single quoted strings do not allow "escaped" characters.
A backslash ("C<\>") represents itself and has no effect
on the interpretation of the next character.
If a rule needs to match one of the forbidden characters
(single quote or vertical whitespace), it must use a
character class.

Single quoted strings are always interpreted at the
G0 level, but they may be used in either structural
or lexical rules.
When a single quoted string is used in a structural rule,
Marpa creates a virtual G0 rule on behalf of the application.
This is handy, but it does have a real disadvantage --
the name of the virtual rule's LHS
will be one assigned automatically by Marpa.
When tracing and debugging parses and grammars,
these virtual LHS's can be harder for a programmer
to interpret.

=head1 Character classes

A character class in square brackets ("C<[]>")
can be used in a RHS alternative of a prioritized rule,
or on the RHS of a quantified rule or a discard rule.
Marpa character classes may contain anything acceptable to Perl,
and follow the same escaping conventions as Perl's character classes.

Character classes are always interpreted at the
G0 level, but they may be used in either structural
or lexical rules.
When a character class is used in a structural rule,
Marpa creates a virtual G0 rule on behalf of the application.
This is handy, but it does have a real disadvantage --
the name of the virtual rule's LHS
will be one assigned automatically by Marpa.
When tracing and debugging parses and grammars,
these virtual LHS's can be harder for a programmer
to interpret.

An implementation note: character classes are
interpreted by Perl, but this involves minimal overhead
when the parse is of any length.
Each character class is
passed to Perl to interpret exactly once and the result is
memoized in a C structure for future use.

=head1 Copyright and License

=for Marpa::R2::Display
ignore: 1

  Copyright 2013 Jeffrey Kegler
  This file is part of Marpa::R2.  Marpa::R2 is free software: you can
  redistribute it and/or modify it under the terms of the GNU Lesser
  General Public License as published by the Free Software Foundation,
  either version 3 of the License, or (at your option) any later version.

  Marpa::R2 is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser
  General Public License along with Marpa::R2.  If not, see
  http://www.gnu.org/licenses/.

=for Marpa::R2::Display::End

=cut

# Local Variables:
#   mode: cperl
#   cperl-indent-level: 4
#   fill-column: 100
# End:
# vim: expandtab shiftwidth=4:


# Copyright 2013 Jeffrey Kegler
# This file is part of Marpa::R2.  Marpa::R2 is free software: you can
# redistribute it and/or modify it under the terms of the GNU Lesser
# General Public License as published by the Free Software Foundation,
# either version 3 of the License, or (at your option) any later version.
#
# Marpa::R2 is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser
# General Public License along with Marpa::R2.  If not, see
# http://www.gnu.org/licenses/.

=head1 Name

Marpa::R2::ASF - Marpa's abstract syntax forests (ASF's)

=head1 Synopsis

and the input,

=for Marpa::R2::Display
name: ASF synopsis input
normalize-whitespace: 1

  my $sentence = 'a panda eats shoots and leaves.';

=for Marpa::R2::Display::End

we can create use an ASF to diagram it in Penntag form:

=for Marpa::R2::Display
name: ASF synopsis output
partial: 1
remove-display-indent: 1
remove-blank-last-line: 1

  (S (NP (DT a) (NN panda))
     (VP (VBZ eats) (NP (NNS shoots) (CC and) (NNS leaves)))
     (. .))
  (S (NP (DT a) (NN panda))
     (VP (VP (VBZ eats) (NP (NNS shoots))) (CC and) (VP (VBZ leaves)))
     (. .))
  (S (NP (DT a) (NN panda))
     (VP (VP (VBZ eats)) (VP (VBZ shoots)) (CC and) (VP (VBZ leaves)))
     (. .))

=for Marpa::R2::Display::End

With the grammar,

=for Marpa::R2::Display
name: ASF synopsis grammar
normalize-whitespace: 1
remove-display-indent: 1
remove-blank-last-line: 1

  :default ::= action => [values] bless => ::lhs
  lexeme default = action => [value] bless => ::name

  S   ::= NP  VP  period  bless => S

  NP  ::= NN              bless => NP
      |   NNS          bless => NP
      |   DT  NN          bless => NP
      |   NN  NNS         bless => NP
      |   NNS CC NNS  bless => NP

  VP  ::= VBZ NP          bless => VP
      | VP VBZ NNS        bless => VP
      | VP CC VP bless => VP
      | VP VP CC VP bless => VP
      | VBZ bless => VP

  period ~ '.'

  :discard ~ whitespace
  whitespace ~ [\s]+

  CC ~ 'and'
  DT  ~ 'a' | 'an'
  NN  ~ 'panda'
  NNS  ~ 'shoots' | 'leaves'
  VBZ ~ 'eats' | 'shoots' | 'leaves'

=for Marpa::R2::Display::End

Here's the code. It actually does two traversals, one that produces the full result as
shown above, and another which "prunes" the forest down to a single tree.

=for Marpa::R2::Display
name: ASF synopsis code
normalize-whitespace: 1

  my $panda_grammar = Marpa::R2::Scanless::G->new( { source => \$dsl } );
  my $panda_recce = Marpa::R2::Scanless::R->new( { grammar => $panda_grammar } );
  $panda_recce->read( \$sentence );
  my $asf = Marpa::R2::ASF->new( { slr=>$panda_recce } );
  my $full_result = $asf->traverse( \&full_traverser );
  my $pruned_result = $asf->traverse( \&pruning_traverser );

=for Marpa::R2::Display::End

=for Marpa::R2::Display
name: ASF synopsis pruning traverser code
normalize-whitespace: 1

  sub penn_tag {
     my ($symbol_name) = @_;
     return q{.} if $symbol_name eq 'period';
     return $symbol_name;
  }

  sub pruning_traverser {

      # This routine converts the glade into a list of Penn-tagged elements.  It is called recursively.
      my ($glade)     = @_;
      my $rule_id     = $glade->rule_id();
      my $symbol_id   = $glade->symbol_id();
      my $symbol_name = $panda_grammar->symbol_name($symbol_id);

      # A token is a single choice, and we know enough to fully Penn-tag it
      if ( not defined $rule_id ) {
	  my $literal = $glade->literal();
	  my $penn_tag = penn_tag($symbol_name);
	  return "($penn_tag $literal)";
      }

      my $length = $glade->rh_length();
      my @return_value = map { $glade->rh_value($_) } 0 .. $length - 1;

      # Special case for the start rule
      return (join q{ }, @return_value) . "\n" if  $symbol_name eq '[:start]' ;

      my $join_ws = q{ };
      $join_ws = qq{\n   } if $symbol_name eq 'S';
      my $penn_tag = penn_tag($symbol_name);
      return "($penn_tag " . ( join $join_ws, @return_value ) . ')';

  }

=for Marpa::R2::Display::End

Here is the "pruned" output:

=for Marpa::R2::Display
name: ASF pruned synopsis output
remove-display-indent: 1
remove-blank-last-line: 1

  (S (NP (DT a) (NN panda))
     (VP (VBZ eats) (NP (NNS shoots) (CC and) (NNS leaves)))
     (. .))

=for Marpa::R2::Display::End

=head1 THIS INTERFACE is ALPHA and EXPERIMENTAL

The interface described in this document is very much a work in progress.
It is alpha and experimental.
The bad side of this is that it is subject to change from version to
version in major ways,
rapidly and without notice.
The good side is that field is 100% open for users
to have feedback into the final interface.

=head1 About this document

This document describes the abstract syntax forests (ASFs) of
Marpa's SLIF interface.
An ASF is an efficient and practical way to represent multiple abstract syntax trees (AST's).

=head1 Constructor

=head2 new()

=for Marpa::R2::Display
name: ASF low-level calls synopsis, code part 1
normalize-whitespace: 1
partial: 1

  my $asf = Marpa::R2::ASF->new( { slr => $slr } );
  die 'No ASF' if not defined $asf;

=for Marpa::R2::Display::End

Creates a new ASF object.
Must be called with a list of one or more hashes of named arguments.
Current only one named argument is allowed, the C<slr> argument, and
that argument is required.
The value of the C<slr> argument must be a SLIF recognizer object.

Returns the new ASF object, or undef if there was a problem.

=head1 Accessor

=head2 grammar()

=for Marpa::R2::Display
name: ASF low-level calls synopsis, code part 2
normalize-whitespace: 1
partial: 1

    my $grammar     = $asf->grammar();

=for Marpa::R2::Display::End

Returns the SLIF grammar associated with the ASF.
This can be convenient when using SLIF grammar methods
while examining an ASF.
All failures are thrown as exceptions.

=head1 Mutator

=head2 traverse()

=for Marpa::R2::Display
name: ASF synopsis code
normalize-whitespace: 1
partial: 1

  my $full_result = $asf->traverse( \&full_traverser );

=for Marpa::R2::Display::End

=head1 Traversal accessors

These are the methods that must be called in the context of a traversal routine.

=head2 literal()

=for Marpa::R2::Display
name: ASF synopsis full traverser code
normalize-whitespace: 1
partial: 1

  my $literal = $glade->literal();

=for Marpa::R2::Display::End

=head2 span()

=for Marpa::R2::Display::Start
name: ASF span() traverser method example
normalize-whitespace: 1
partial: 1

  my ( $start, $length ) = $glade->span();
  my $end = $start + $length - 1;

=for Marpa::R2::Display::End

=head2 symbol_id()

=for Marpa::R2::Display
name: ASF synopsis full traverser code
normalize-whitespace: 1
partial: 1

    my $symbol_id   = $glade->symbol_id();

=for Marpa::R2::Display::End

=head2 rule_id()

=for Marpa::R2::Display
name: ASF synopsis full traverser code
normalize-whitespace: 1
partial: 1

  my $rule_id     = $glade->rule_id();

=for Marpa::R2::Display::End

=head2 rh_length()

=for Marpa::R2::Display
name: ASF synopsis full traverser code
normalize-whitespace: 1
partial: 1

  my $length = $glade->rh_length();

=for Marpa::R2::Display::End

=head2 rh_value()

=for Marpa::R2::Display
name: ASF synopsis full traverser code
normalize-whitespace: 1
partial: 1

  my $child_value = $glade->rh_value($rh_ix);

=for Marpa::R2::Display::End

=head2 next()

=for Marpa::R2::Display
name: ASF synopsis full traverser code
normalize-whitespace: 1
partial: 1

  last CHOICE if not defined $glade->next();

=for Marpa::R2::Display::End

=head1 Appendix: full traverser code

=for Marpa::R2::Display
name: ASF synopsis full traverser code
normalize-whitespace: 1

  sub full_traverser {

      # This routine converts the glade into a list of Penn-tagged elements.  It is called recursively.
      my ($glade)     = @_;
      my $rule_id     = $glade->rule_id();
      my $symbol_id   = $glade->symbol_id();
      my $symbol_name = $panda_grammar->symbol_name($symbol_id);

      # A token is a single choice, and we know enough to fully Penn-tag it
      if ( not defined $rule_id ) {
	  my $literal = $glade->literal();
	  my $penn_tag = penn_tag($symbol_name);
	  return ["($penn_tag $literal)"];
      } ## end if ( not defined $rule_id )

      # Our result will be a list of choices
      my @return_value = ();

      CHOICE: while (1) {

	  # The results at each position are a list of choices, so
	  # to produce a new result list, we need to take a Cartesian
	  # product of all the choices
	  my $length = $glade->rh_length();
	  my @results = ( [] );
	  for my $rh_ix ( 0 .. $length - 1 ) {
	      my @new_results = ();
	      for my $old_result (@results) {
		  my $child_value = $glade->rh_value($rh_ix);
		  for my $new_value ( @{ $child_value } ) {
		      push @new_results, [ @{$old_result}, $new_value ];
		  }
	      }
	      @results = @new_results;
	  } ## end for my $rh_ix ( 0 .. $length - 1 )

	  # Special case for the start rule
	  if ( $symbol_name eq '[:start]' ) {
	      return [ map { join q{}, @{$_} } @results ];
	  }

	  # Now we a list of choices, as a list of lists.  Each sub list
	  # is a list of Penn-tagged elements, which we need to join into
	  # a single Penn-tagged element.  The result will be to collapse
	  # one level of lists, and leave us with a list of Penn-tagged
	  # elements
	  my $join_ws = q{ };
	  $join_ws = qq{\n   } if $symbol_name eq 'S';
	  push @return_value,
	      map { '(' . penn_tag($symbol_name) . q{ } . ( join $join_ws, @{$_} ) . ')' }
	      @results;

	  # Look at the next alternative in this glade, or end the
	  # loop if there is none
	  last CHOICE if not defined $glade->next();

      } ## end CHOICE: while (1)

      # Return the list of Penn-tagged elements for this glade
      return \@return_value;
  } ## end sub full_traverser

=for Marpa::R2::Display::End

=head1 Copyright and License

=for Marpa::R2::Display
ignore: 1

  Copyright 2013 Jeffrey Kegler
  This file is part of Marpa::R2.  Marpa::R2 is free software: you can
  redistribute it and/or modify it under the terms of the GNU Lesser
  General Public License as published by the Free Software Foundation,
  either version 3 of the License, or (at your option) any later version.

  Marpa::R2 is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser
  General Public License along with Marpa::R2.  If not, see
  http://www.gnu.org/licenses/.

=for Marpa::R2::Display::End

=cut

# Local Variables:
#   mode: cperl
#   cperl-indent-level: 4
#   fill-column: 100
# End:
# vim: expandtab shiftwidth=4:

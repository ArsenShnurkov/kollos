# Copyright 2013 Jeffrey Kegler
# This file is part of Marpa::R2.  Marpa::R2 is free software: you can
# redistribute it and/or modify it under the terms of the GNU Lesser
# General Public License as published by the Free Software Foundation,
# either version 3 of the License, or (at your option) any later version.
#
# Marpa::R2 is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser
# General Public License along with Marpa::R2.  If not, see
# http://www.gnu.org/licenses/.

=head1 NAME

Marpa::R2 - Release 2 of Marpa

=head1 Synopsis

=for Marpa::R2::Display
name: Landing page synopsis
normalize-whitespace: 1

    use Marpa::R2;

    my $grammar = Marpa::R2::Scanless::G->new(
        {   action_object  => 'My_Nodes',
            default_action => 'first_arg',
            source         => \(<<'END_OF_SOURCE'),
    :start ::= Expression
    Expression ::= Term
    Term ::=
          Factor
        | Term '+' Term action => do_add
    Factor ::=
          Number
        | Factor '*' Factor action => do_multiply
          Number ~ digits
          digits ~ [\d]+
          :discard ~ whitespace
          whitespace ~ [\s]+
    END_OF_SOURCE
        }
    );

    my $recce = Marpa::R2::Scanless::R->new( { grammar => $grammar } );
    my $input = '42 * 1 + 7';
    $recce->read( \$input );

    my $value_ref = $recce->value;
    my $value = $value_ref ? ${$value_ref} : 'No Parse';

    package My_Nodes;

    sub new { return {}; }

    sub do_add {
        my ( undef, $t1, undef, $t2 ) = @_;
        return $t1 + $t2;
    }

    sub do_multiply {
        my ( undef, $t1, undef, $t2 ) = @_;
        return $t1 * $t2;
    }

    sub first_arg { shift; return shift; }

=for Marpa::R2::Display::End

=head1 Description

=head2 Overview

Marpa parses any language whose
grammar can be written in BNF.
That includes recursive grammars,
ambiguous grammars, infinitely ambiguous grammars and
grammars with useless or empty productions.

This document contains a top-level overview
of the API for the Marpa parse engine.
The two examples in this document
show the typical flows of Marpa method calls.
This document will use these examples
to describe the basic features of Marpa
in semi-tutorial fashion.
Marpa's advanced features, and full reference details of all features,
can be found in L<the other Marpa API documents|/"Other documents">.

=head1 A simple calculator

The synopsis shows the code for a very simple calculator.
It handles only
addition and multiplication of integers.
This section explains, line by line, how it works.

=head2 Marpa::R2::Scanless::G::new

=for Marpa::R2::Display
name: Landing page synopsis
partial: 1
normalize-whitespace: 1

    my $grammar = Marpa::R2::Scanless::G->new(
        {   action_object  => 'My_Nodes',
            default_action => 'first_arg',
            source         => \(<<'END_OF_SOURCE'),
    :start ::= Expression
    Expression ::= Term
    Term ::=
          Factor
        | Term '+' Term action => do_add
    Factor ::=
          Number
        | Factor '*' Factor action => do_multiply
          Number ~ digits
          digits ~ [\d]+
          :discard ~ whitespace
          whitespace ~ [\s]+
    END_OF_SOURCE
        }
    );

=for Marpa::R2::Display::End

SLIF grammars are
L<C<Marpa::R2::Scanless:G>|Marpa::R2::Scanless::G> objects.
They are created
with the
L<Marpa::R2::Scanless:G::new|Marpa::R2::Scanless::G/"new">
constructor.
The arguments to
L<Marpa::R2::Scanless::G::new|Marpa::R2::Scanless::G/"new">
are references to
hashes of named arguments.
In the key/value pairs of these hashes,
the
hash key
is the
name of the argument,
and the
hash value
is the
value of the named argument.

=head3 The start named argument

=for Marpa::R2::Display
name: Landing page synopsis
partial: 1
normalize-whitespace: 1

    start => 'Expression',

=for Marpa::R2::Display::End

The C<start> named argument is required.
Its value is
a string containing the name of the grammar's start symbol.

=head3 Named arguments for the semantics

=for Marpa::R2::Display
name: Landing page synopsis
partial: 1
normalize-whitespace: 1

            actions => 'My_Actions',
            default_action => 'first_arg',

=for Marpa::R2::Display::End

The C<actions> and C<default_action> named arguments specify
semantics.
Their argument values are strings,
which acquire their semantics during evaluation.

Evaluation will be described later.
Peeking ahead,
C<actions> provides the name
of a Perl package where Marpa will look for
its B<actions>.
The C<default_action> named argument
will be interpreted
as an B<action name> in that package.
This action name will resolve to an action --
a Perl closure that implements semantics.
The action specified by C<default_action>
is used as the action for rules
with no action of their own.

=head3 The rules named argument

=for Marpa::R2::Display
name: Landing page synopsis
partial: 1
normalize-whitespace: 1

    rules => [
        { lhs => 'Expression', rhs => [qw/Term/] },
        { lhs => 'Term',       rhs => [qw/Factor/] },
        { lhs => 'Factor',     rhs => [qw/Number/] },
        { lhs => 'Term', rhs => [qw/Term Add Term/], action => 'do_add' },
        {   lhs    => 'Factor',
            rhs    => [qw/Factor Multiply Factor/],
            action => 'do_multiply'
        },
    ],

=for Marpa::R2::Display::End

The value of the
C<rules> named argument is a reference to an array of
B<rule descriptors>.
In this example, all the rule descriptors are in the "long" form --
they are references to hashes of B<rule properties>.
In each key/value pair of a rule descriptor hash, the key is
the name of a rule property, and the hash value is the value of
that rule property.

=head4 The lhs property

The value of the C<lhs> rule property must be a string containing
the name of the rule's left hand side symbol.
Every Marpa rule must have a left hand side symbol.

=head4 The rhs property

The value of the C<rhs> property is a reference to
an array of strings containing
names of the rule's right hand symbols,
in order.
This array may be zero length, in which case
this is an B<empty rule> --
a rule with no symbols on the right hand side.
There are no empty rules in this example.

=head4 The action property

The value of the C<action> rule property is a string.
Peeking ahead, each C<action> property string
will be interpreted
as an action name.
This action name will be resolved
to a Perl closure that
implements
the rule's semantics.

=head2 Marpa::R2::Scanless::R::new

=for Marpa::R2::Display
name: Landing page synopsis
partial: 1
normalize-whitespace: 1

    my $recce = Marpa::R2::Scanless::R->new( { grammar => $grammar } );

=for Marpa::R2::Display::End

C<Marpa::R2::Scanless::R::new> creates a new SLIF recognizer.
Its arguments are references to hashes of named arguments.
In this example the only named argument is
the required argument: "C<grammar>".
The value of the
C<grammar>
named argument must be a Marpa SLIF
grammar.

=head2 Marpa::R2::Scanless::R::read

=for Marpa::R2::Display
name: Landing page synopsis
partial: 1
normalize-whitespace: 1

    my $input = '42 * 1 + 7';
    $recce->read( \$input );

=for Marpa::R2::Display::End

To parse a string,
we use 
the C<Marpa::R2::Scanless::R::read()> method.
In its simplest form,
as here,
the C<Marpa::R2::Scanless::R::read()> takes a reference
to a string containing the input stream as its argument.

=head2 Marpa::R2::Scanless::R::value

=for Marpa::R2::Display
name: Landing page synopsis
partial: 1
normalize-whitespace: 1

    my $value_ref = $recce->value;
    my $value = $value_ref ? ${$value_ref} : 'No Parse';

=for Marpa::R2::Display::End

The C<Marpa::R2::Scanless::R::value()> method returns
a reference to the parse result's value,
if there was a parse result.
If there was no parse result,
C<Marpa::R2::Scanless::R::value()>
returns
C<undef>.

=head2 Resolving the semantics

The first thing C<Marpa::R2::Scanless::R::value()> needs to do is
to resolve the semantics.
B<Resolving the semantics> means
mapping the action names into actions.
B<Actions> are Perl
closures which directly implement semantics.
In this example,
the C<actions> named argument is specified.
C<actions> is a Perl package name.
Marpa will look for actions
in that package.

=for Marpa::R2::Display
name: Landing page synopsis
partial: 1
normalize-whitespace: 1

    actions => 'My_Actions',

=for Marpa::R2::Display::End

=for Marpa::R2::Display
name: Landing page synopsis
partial: 1
normalize-whitespace: 1
flatten: 1

    { lhs => 'Factor', rhs => [qw/Factor Multiply Factor/], action => 'do_multiply' },

=for Marpa::R2::Display::End

For example, the C<action> property for the above rule
is "C<do_multiply>" and the C<actions> named argument to the grammar
was "C<My_Actions>".
So Marpa looks for a closure whose fully qualified name is C<My_Actions::do_multiply>,
which it finds:

=for Marpa::R2::Display
name: Landing page synopsis
partial: 1
normalize-whitespace: 1

    sub My_Actions::do_multiply {
        my ( undef, $t1, undef, $t2 ) = @_;
        return $t1 * $t2;
    }

=for Marpa::R2::Display::End

Rules do not always have C<action> properties.
That is the case with these rules in this example:

=for Marpa::R2::Display
name: Landing page synopsis
partial: 1
normalize-whitespace: 1

    { lhs => 'Expression', rhs => [qw/Term/] },
    { lhs => 'Term', rhs => [qw/Factor/] },
    { lhs => 'Factor', rhs => [qw/Number/] },

=for Marpa::R2::Display::End

The rules in the above display have no action names.
When a rule has no action name,
Marpa will fall back to trying to use
the default action,
as described next.

=for Marpa::R2::Display
name: Landing page synopsis
partial: 1
normalize-whitespace: 1

    default_action => 'first_arg',

=for Marpa::R2::Display::End

The C<default_action> named argument is resolved in the same way
as are the C<action> properties of the
rules.
In this example,
default_action is specified as "C<first_arg>"
and resolves to
C<My_Actions::first_arg>.

=head2 Actions

=for Marpa::R2::Display
name: Landing page synopsis
partial: 1
normalize-whitespace: 1

    sub My_Actions::first_arg { shift; return shift; }

=for Marpa::R2::Display::End

=for Marpa::R2::Display
name: Landing page synopsis
partial: 1
normalize-whitespace: 1

    sub My_Actions::do_add {
        my ( undef, $t1, undef, $t2 ) = @_;
        return $t1 + $t2;
    }

=for Marpa::R2::Display::End

Value actions are Perl closures used as callbacks.
Value actions are called when nodes in a parse tree are evaluated.
A value action receives one or more arguments.
The first argument to a value action is always a per-parse-tree
object, which the callbacks can use as a scratchpad.
In these examples, the per-parse-tree object is not used.

For a non-empty rule,
the second and any subsequent arguments to the callback are
the values,
in lexical order,
of the symbols on the right hand side of
the rule.
If the action is for an empty rule,
the per-parse-tree object will be its only argument.

Every value action is expected to return a value.
With one exception,
this value is passed up to a parent node
as an argument.
The exception is the value for the start rule.
The return value for the start rule becomes
the parse result.

Rules with no action specified for them take their
semantics from the C<default_action> named argument.
If there is no default action for a grammar,
rules with no action specified for them
return a Perl C<undef>.

=head1 Errors and exceptions

Methods in the Marpa API usually do not return errors.
When there are errors,
Marpa API methods throw an exception.

=head1 Inheritance

Classes in Marpa's API's are not designed to
be inherited.

=head1 The Marpa:: namespace

The C<Marpa::> top-level namespace is reserved.
For extensions to Marpa,
one appropriate place is the C<MarpaX::> namespace.
This practice helps avoid namespace collisions,
and follows a CPAN standard, as exemplified by
the
C<DBIx::>
C<LWPx::>
and
C<MooseX::>
which are for extensions of, respectively,
DBI, LWP and Moose.

=head1 Other documents

This document gives a semi-tutorial overview of Marpa's Scanless interface (SLIF).
For more details about the SLIF,
there is an
L<overview|Marpa::R2::Scanless>,
and pages describing
L<its DSL|Marpa::R2::Scanless::DSL>,
L<its grammar methods|Marpa::R2::Scanless:G>,
and
L<its recognizer methods|Marpa::R2::Scanless:R>.

Marpa has two other interfaces which may be of interest.
An older, more traditional, interface
is the named argument inteface (NAIF) for the Marpa parse engine.
The NAIF is a middle level interface which used Perl calls
instead of a DSL.
The NAIF is more low level than
L<the Scanless interface
(SLIF)|Marpa::R2::Scanless>,
which uses a domain-specific language.

There is also the L<the thin
interface|<Marpa::R2::Advanced::Thin>,
which provides direct access to the underlying
Libmarpa C library.
The thin interface offers efficient access to the full power of the
Marpa parse engine,
but it requires the application to do a lot more of the work itself.

L<Marpa::R2::Vocabulary> is intended as a quick refresher in
parsing terminology,
emphasizing how the standard terms are used
in the Marpa context.
Marpa's standard semantics are fully described in the
L<Marpa::R2::Semantics> document.
Techniques for tracing and for debugging your Marpa grammars
are described in the
L<Marpa::R2::Tracing> document and the
L<Marpa::R2::Progress> document.
For those with a theoretical bent,
my sources, and other useful references, are described in
L<Marpa::R2::Advanced::Bibliography>.

=head1 Author

Jeffrey Kegler

=head2 Why is it called "Marpa"?

Marpa is the name of the greatest of the Tibetan "translators".
In his time (the 11th century AD) Indian Buddhism was
at its height.
Marpa's generation of scholars was devoted
to producing Tibetan versions of Buddhism's Sanskrit scriptures.
Marpa became the greatest of them,
and today is known as Marpa Lotsawa: "Marpa the Translator".

=head2 Blatant plug

Marpa is a character in my novel, B<The God Proof>.
B<The God
Proof> centers around Kurt GE<ouml>del's proof of God's existence.
Yes, I<that> Kurt GE<ouml>del, and yes, he really did work out a
God Proof (it's in his I<Collected Works>, Vol. 3, pp. 403-404).
B<The God Proof> is available
as a free download (L<http://www.lulu.com/content/933192>).
It can be purchased in print form at Amazon.com:
L<http://www.amazon.com/God-Proof-Jeffrey-Kegler/dp/1434807355>.

=head1 Support

L<Marpa::R2> comes without warranty.
Support is provided
on a volunteer basis
through the standard mechanisms for CPAN modules.
L<The Support document|Marpa::R2::Support> has details.

=head1 Copyright and License

=for Marpa::R2::Display
ignore: 1

  Copyright 2013 Jeffrey Kegler
  This file is part of Marpa::R2.  Marpa::R2 is free software: you can
  redistribute it and/or modify it under the terms of the GNU Lesser
  General Public License as published by the Free Software Foundation,
  either version 3 of the License, or (at your option) any later version.

  Marpa::R2 is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser
  General Public License along with Marpa::R2.  If not, see
  http://www.gnu.org/licenses/.

=for Marpa::R2::Display::End

=cut

# Local Variables:
#   mode: cperl
#   cperl-indent-level: 4
#   fill-column: 100
# End:
# vim: expandtab shiftwidth=4:


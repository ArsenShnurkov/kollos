# Copyright 2013 Jeffrey Kegler
# This file is part of Marpa::R2.  Marpa::R2 is free software: you can
# redistribute it and/or modify it under the terms of the GNU Lesser
# General Public License as published by the Free Software Foundation,
# either version 3 of the License, or (at your option) any later version.
#
# Marpa::R2 is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser
# General Public License along with Marpa::R2.  If not, see
# http://www.gnu.org/licenses/.

=head1 NAME

Marpa::R2::Semantics - How Marpa evaluates parses

=head1 Synopsis

=for Marpa::R2::Display
name: SLIF full synopsis
normalize-whitespace: 1

    use Marpa::R2;

    my $grammar = Marpa::R2::Scanless::G->new(
        {   bless_package => 'My_Nodes',
            source        => \(<<'END_OF_SOURCE'),
    :default ::= action => [values] bless => ::lhs
    lexeme default = action => [start,length,value] bless => ::name

    :start ::= Script
    Script ::= Expression+ separator => comma
    comma ~ [,]
    Expression ::=
        Number bless => primary
        | '(' Expression ')' bless => paren assoc => group
       || Expression '**' Expression bless => exponentiate assoc => right
       || Expression '*' Expression bless => multiply
        | Expression '/' Expression bless => divide
       || Expression '+' Expression bless => add
        | Expression '-' Expression bless => subtract

    Number ~ [\d]+
    :discard ~ whitespace
    whitespace ~ [\s]+
    # allow comments
    :discard ~ <hash comment>
    <hash comment> ~ <terminated hash comment> | <unterminated
       final hash comment>
    <terminated hash comment> ~ '#' <hash comment body> <vertical space char>
    <unterminated final hash comment> ~ '#' <hash comment body>
    <hash comment body> ~ <hash comment char>*
    <vertical space char> ~ [\x{A}\x{B}\x{C}\x{D}\x{2028}\x{2029}]
    <hash comment char> ~ [^\x{A}\x{B}\x{C}\x{D}\x{2028}\x{2029}]
    END_OF_SOURCE
        }
    );


    my $recce = Marpa::R2::Scanless::R->new( { grammar => $grammar } );

    my $input = '42*2+7/3, 42*(2+7)/3, 2**7-3, 2**(7-3)';
    $recce->read(\$input);
    my $value_ref = $recce->value();
    die "No parse was found\n" if not defined $value_ref;

    # Result will be something like "86.33... 126 125 16"
    # depending on the floating point precision
    my $result = ${$value_ref}->doit();

    package My_Nodes;

    sub My_Nodes::primary::doit { return $_[0]->[0]->doit() }
    sub My_Nodes::Number::doit  { return $_[0]->[2] }
    sub My_Nodes::paren::doit   { my ($self) = @_; $self->[1]->doit() }

    sub My_Nodes::add::doit {
        my ($self) = @_;
        $self->[0]->doit() + $self->[2]->doit();
    }

    sub My_Nodes::subtract::doit {
        my ($self) = @_;
        $self->[0]->doit() - $self->[2]->doit();
    }

    sub My_Nodes::multiply::doit {
        my ($self) = @_;
        $self->[0]->doit() * $self->[2]->doit();
    }

    sub My_Nodes::divide::doit {
        my ($self) = @_;
        $self->[0]->doit() / $self->[2]->doit();
    }

    sub My_Nodes::exponentiate::doit {
        my ($self) = @_;
        $self->[0]->doit()**$self->[2]->doit();
    }

    sub My_Nodes::Script::doit {
        my ($self) = @_;
        return join q{ }, map { $_->doit() } @{$self};
    }

=for Marpa::R2::Display::End

=head1 About this document

B<This document is under construction.>
It is being converted to describe Marpa's primary interface, the SLIF.
Currently,
much of it actually describes an older and more low-level Marpa interface, the NAIF.

=head1 What is semantics?

A parser is something that takes a string of symbols (tokens or characters) and finds a structure
in it.
Traditionally, that structure is a tree.

Rarely is an application interested only in the tree.
Usually the idea is that the string "means" something --
the idea is that the string has a B<semantics>.
Traditionally and most often, the tree
is as an intermediate step in producing a value,
a value which represents the "meaning" or "semantics" of the string.

"Evaluating" a tree means finding its semantics.
The rest of this document describes Marpa's methods for evaluating trees.
Those of you who have dealt with other traditional parsers, such as yacc and bison,
will find Marpa's approach familiar.

Evaluation only takes place within the structural (G1) subgrammar,
and the descriptions of the behaviors of rules and lexemes applies only
to the G1 subgrammar.
G0 rules and terminal symbols do not become nodes
in the parse tree,
they have no actions,
and they are never evaluated.

=head1 Nodes

In a parse tree, nodes are points where the tree branches or terminates.
Tree terminations are also called terminals or "leaves".

Every rule instance in a Marpa parse is reprsented by a branch point (or "node")
in the tree.
The topmost node of a tree is its "root node".
(Trees are easiest to draw upside down, so traditionally in programming,
the top of a tree is its root.)

A node, or branch point, "branches" into zero or more "child nodes".
The node just above a child node,
the one from which the child node branches out,
is called its parent node.

If the node is for a BNF rule,
the parent node is the LHS of the rule,
and the child nodes are the RHS of the rule.
If the node is for a sequence rule,
the parent node is the LHS of the sequence rule,
and the child nodes are the items of the sequence.
If the node is for a lexeme,
the node represents the lexeme's symbol
and there will be no child nodes.

A parent node can have zero or more children.
Rules with zero children are nulled rules,
and are "leaf nodes" or terminals.
In Marpa's parse trees, every leaf node is either
a lexeme or a nulled rule.

=head1 The order of node evaluation

The nodes of a Marpa parse tree are
evaluated recursively, left-to-right and bottom-up.
This means that,
when a parent node is evaluated,
the values of all child nodes are known
and available for use by the semantics.
The final value of a parse is the value of the top node
of the parse tree.

=head1 Nulled subtrees

A nulled subtree is the tree formed by a nulled node and its direct and
indirect child nodes.
(All these child nodes will also be nulled nodes.)
Before evaluation,
Marpa prunes all nulled subtrees back to their topmost nulled
node.
Of all the ways of dealing with nulled subtrees, this is the
simplest and
Marpa's users have found it a natural approach.
More detail on the semantics of nulled symbols and subtrees
can be found in
L<a separate document|Marpa::R2::Semantics::Null>.

When a node is nulled,
it must be as a result of a nullable rule,
and the action name and action are those
associated with that rule.
An ambiguity can arise if there is more
than one nullable rule with the same LHS,
but a different action name.
In that case the action name for the null nodes
is that of the empty rule.

The remaining case is that of
a set of nullable rules with the same LHS,
where two or more of the rules have different action names,
but none of the rules in the set is an empty rule.
When this happens, Marpa throws an exception.
To fix the issue,
the user can add an empty rule.
For more details,
see L<the document on
null semantics|Marpa::R2::Semantics::Null>.

=head1 Actions

What the SLIF does at each node is called that node's B<action>.
Actions can be explicit or implicit.
An explicit action is one that is specified in one of the ways
to be described below.
A node's implicit action is the one it performs if it has no
explicit action.

The next sections describe,
by type of parse tree node,
how explicit action names can be specified,
and the implicit action.
This document then proceeds to
describe how explicit action names resolve to actions.

=head2 Lexeme actions

The implicit action for a lexeme is to return
its literal value in the stream, as a string.
An explicit default may be set using the
L<the lexeme default statement|Marpa::R2::Scanless::DSL/"Lexeme default statement">.

=head2 Rule actions

The implicit action for a rule is to return a Perl C<undef>.
An explicit action for a rule can be specified using
L<the C<action> adverb|Marpa::R2::Scanless::DSL/"action">
for the rule or, in the case of a prioritized rule, the RHS alternative.
A default explicit action for rules can be specified with a
L<default pseudo-rule|Marpa::R2::Scanless::DSL/"Default pseudo-rules">.

=head1 Array descriptor actions

=for Marpa::R2::Display
name: SLIF DSL synopsis
partial: 1
normalize-whitespace: 1

    lexeme default = action => [start,length,value] bless => ::name

=for Marpa::R2::Display::End

If an action is enclosed in square brackets, it is an B<array descriptor>,
and the value of the lexeme or rule will be an array.
Inside the array descriptor should a comma separated list of zero or more array
descriptor items.
The B<array descriptor items> are keywords that describe how the array is to be filled
out.

If the array descriptor is an empty pair of square brackets ("C<[]>"),
then there are zero array descriptor items,
and the value will be an empty array.
Otherwise the "array descriptor item" keywords are interpreted as lists
and those lists are used to fill out the 
array.
A C<start> array descriptor item will put
the start location of the rule or lexeme into the array.
The C<length> array descriptor item will put
the length of the rule or lexeme into the array.
The start location is an offset in the input string.
Length is in characters
and is defined such that the end location
is always start location plus length.

For a rule,
the C<values> array descriptor item indicates a list containing
the values of
the rule's children, in left-to-right order.
For a lexeme, 
the C<value> array descriptor item indicates a list
containing a single element,
the token value of the lexeme.

C<::array> is equivalent to C<[values]>.
The C<value> and C<values> array descriptor items are synonyms,
and may be used interchangeably for both rules and lexemes.
This means that, for both lexemes and rules,
the actions C<[values]>, C<[value]> and C<::array>
will do exactly the same thing.

The array descriptor item keywords fill out the array in
the order in which they appear in the the array descriptor.
For example, if we are dealing with a rule,
and the array descriptor is "C<[start,length,value]>",
then the return value is an reference to an array,
whose length will vary, but which will be contain least
three elements.
The first element will be the start location in the
input string of this rule instance,
and the second will be its length.
The remaining elements will be
the values of the rule's RHS children,
in lexical order,
as computed according to the semantics
of those children.

=head1 Reserved action names

If the action value begins with a double colon ("C<::>"),
it is a reserved action.
The following are recognized:

=over 4

=item * C<::array>

The value of the rule or lexeme is an array.
For a rule, the array will
contain the
values of each of its children, in left-to-right order.
If the rule has no children, the array will be empty.
For a lexeme, the array will be of length one,
and will contain the token value.

=item * C<::first>

The value of the rule is that of the rule's first child.
If there is no such child, the value is a Perl C<undef>.

It is a fatal error if a blessing
is applied to a rule with a C<::first> action.
This is the case even when either or both adverbs are
the result of a default.
It is also a fatal error to use a C<::first> action
with a lexeme.

=item * C<::undef>

The value of the rule or lexeme is 
a Perl C<undef>.
It is a fatal error if a blessing
is applied to a rule with a C<::undef> action.
This is the case even when either or both adverbs are
the result of a default.

=back

=head2 Perl identifers

If the action value is a Perl identifier,
it is treated as the name of a Perl variable,
but one which still must be fully qualified by adding a package name.
For this purpose, a Perl identifier is a sequence of one or more alphanumerics
and underscores.
A Perl identifier will be fully qualified by prefixing the name of the semantic package,
and then dealt with as described for L<"Fully qualified Perl names">.

For example, if the action value
is "C<some_var>", the action value will be regarded as a Perl identifer.
If the semantics package is "C<My_Actions>", Marpa will convert the action
value to "C<My_Actions::some_var>", and hand
it on for processing as a fully qualified Perl name.
is "C<some_var>", the action value will be regarded as a Perl identifer.
For more details on qualifying Perl identifiers, see
L<the document on SLIF semantics|Marpa::R2::Semantics>.

=head1 Perl names as actions

If an action value is a series of two or more Perl identifiers
separated by double colons ("C<::>"), it is treated as it was a fully qualified Perl name.
Fully qualified Perl names are also obtained from action names which look like
unqualified Perl names, by prefixing the semantics package, as described above.
(Note that an action value starting with a double colon is always treated as a reserved
action name and is B<not> regarded as Perl name.)

=head2 Resolution to a Perl semantic closure

Ordinarily, the arguments to the semantic closure are the per-parse-tree
variable,
followed by values of the rule's child nodes,
in the order in which they occurred in the input stream.
However,
if a rule with a word action is blessed,
in order to allow the blessing to take effect,
the arguments to a semantic closure are formed differently.
If the rule is blessed, its semantic closure will always have
exactly two arguments.
The first will be the per-parse-tree variable.
The second will be a blessed array that contains
the child values in input-stream order.

Note that the above implies that resolution can be either to a Perl subroutine
or to a reference to a Perl subroutine, but that the result will be very different.
The Perl subroutine will be treated as a semantic closure, and executed to produce
the value of the node.
The reference to a subroutine will B<NOT> be treated as a semantic closure,
and will not be executed.
The reference to a Perl subtroutine will be passed on, as is, as the value of the node.

=head1 The semantics package

If the user wants to leave the
rule evaluation closures in the C<main> namespace,
she can specify
C<"main">
as the value of the C<actions> named argument.
But
it can be good practice to keep
the rule evaluation closures
in their own namespace,
particularly if the application is not small.

=head1 Resolving Perl identifier actions to Perl names

If the action name resolves to a scalar Perl variable,
that is the value of the rule.
Users should note that the resolution to a Perl variable resolves to the same
variable every time.
Further, assuming no trickery with Perl's C<local> keyword take place,
this Perl variable will be global in scope.
This means that good practice suggest that resolution to Perl variables be restricted
to constants.

For example, it may seem easier to initialize a hash in a parse tree
using an action which returns a reference to an empty hash.
Unfortunately for this purpose, this will be the same hash for
all its users, and any change to it will be seen by all users.
This is almost certainly not what is wanted.
Users who want an action that returns an different empty hash every time
it is invoked, which is almost always what is wanted,
will need their action to resolve to a semantic closure,
not a Perl variable.

For an Perl identifier name to resolve successfully
a semantics package must be defined.

=head1 Resolving Perl names action to Perl variables

Once Marpa has a fully qualified Perl name, it looks in Perl's symbol tables for
a Perl variable with that name,
either the name of a subroutine, or of a scalar.
It is important to note that for the purposes of Perl's symbol tables,
and therefore for the purposes of Marpa's resolution of Perl names,
references are scalars.
If Marpa finds a Perl subroutine with that fully qualified Perl name,
the action name is resolved to that subroutine,
which then becomes a B<semantic closure>.
If Marpa does not find
a Perl subroutine with that name,
but does find a scalar Perl variable with that name,
the action name is resolved to that Perl variable.
(Again, for this purpose a Perl reference is a kind of Perl scalar.)

=head2 Resolution to a Perl semantic closure

Ordinarily, the arguments to the semantic closure are the per-parse-tree
variable,
followed by values of the rule's child nodes,
in the order in which they occurred in the input stream.
However,
if a rule with a word action is blessed,
in order to allow the blessing to take effect,
the arguments to a semantic closure are formed differently.
If the rule is blessed, its semantic closure will always have
exactly two arguments.
The first will be the per-parse-tree variable.
The second will be a blessed array that contains
the child values in input-stream order.

Note that the above implies that resolution can be either to a Perl subroutine
or to a reference to a Perl subroutine, but that the result will be very different.
The Perl subroutine will be treated as a semantic closure, and executed to produce
the value of the node.
The reference to a subroutine will B<NOT> be treated as a semantic closure,
and will not be executed.
The reference to a Perl subtroutine will be passed on, as is, as the value of the node.

=head1 Executing rule evaluation closures

If a node is not a token node,
then it is a B<rule node>.
Rule nodes are always
associated with a rule.
It a rule's action is a rule evaluation closure,
it is called at
L<Node Evaluation Time|/"Tree Traversal Phase">.

The rule evaluation closures's
arguments will be a
per-parse-tree variable followed, if the rule is not nulled,
by the values of its child nodes in lexical order.
If the rule is nulled, the child node values will be omitted.
A rule evaluation closure action is always called in scalar context.

=head2 Sequence rule nodes

Some rules are L<sequence rules|Marpa::R2::NAIF::Grammar/"Sequence rules">.
Sequence rule nodes are also rule nodes.
Everything said above about rule nodes
applies to sequence rule nodes.
Specifically,
the arguments to the value actions for sequence rules
are the
per-parse-tree variable followed by
the values of the child nodes in lexical order.

The difference (and it is a big one)
is that in an ordinary rule, the right hand side
is fixed in length, and that length is known
when you are writing the code for the value action.
In a sequence rule,
the number of right hand side symbols is not known
until node evaluation time.
The rule evaluation closure
of a sequence rule
must be capable of
dealing with
a variable number of arguments.

Sequence semantics work best when
every child node
in the sequence has the same semantics.
When that is not the case,
writing the sequence using
ordinary non-sequence rules should be considered as
an alternative.

By default, if a sequence rule has separators,
the separators are thrown away before
the value action is called.
(Separators are described in
L<the section introducing sequence rules|Marpa::R2::NAIF::Grammar/"Sequence rules">.)
This means that separators do not appear in the C<@_> array
of the rule evaluation closure which is the value action.
If the value of the C<keep> rule property
is a Perl true value, separators are kept,
and do appear in the
value action's
C<@_> array.

=head2 Null nodes

A null node is a special case of a rule node,
one where the rule derives the zero-length,
or empty string.
When the rule node is a null node,
the rule evaluation closure will be called with
no child value arguments.

When a node is nulled,
it must be as a result of a nullable rule,
and the action name and action are those
associated with that rule.
An ambiguity can arise if there is more
than one nullable rule with the same LHS,
but a different action name.
In that case the action name for the null nodes
is that of the empty rule.

The remaining case is that of
a set of nullable rules with the same LHS,
where two or more of the rules have different action names,
but none of the rules in the set is an empty rule.
When this happens, Marpa throws an exception.
To fix the issue,
the user can add an empty rule.
For more details,
see L<the document on
null semantics|Marpa::R2::Semantics::Null>.

=head1 Action context

=for Marpa::R2::Display
name: SLIF action context synopsis
normalize-whitespace: 1

    sub do_S {
        my ($action_object) = @_;
        my $rule_id         = $Marpa::R2::Context::rule;
        my $grammar         = $Marpa::R2::Context::grammar;
        my ( $lhs, @rhs ) = $grammar->rule($rule_id);
        $action_object->{text} =
              "rule $rule_id: $lhs ::= "
            . ( join q{ }, @rhs ) . "\n"
            . "locations: "
            . ( join q{-}, Marpa::R2::Context::location() ) . "\n";
        return $action_object;
    } ## end sub do_S

=for Marpa::R2::Display::End

In addition to the per-parse-tree variable
and their child arguments,
rule evaluation closures also have access
to B<context variables>.

=over

=item * C<$Marpa::R2::Context::grammar> is set to
the grammar being parsed.

=item * C<$Marpa::R2::Context::rule> is the ID of the
current rule.
Given the rule ID, an application can find
its LHS and RHS symbols using
L<the SLIF grammar's C<rule()> method|Marpa::R2::Scanless::G/"rule">.

=item * C<Marpa::R2::Context::location()> returns the start
and end locations of the current rule.

=back

=head1 Bailing out of parse evaluation

=for Marpa::R2::Display
name: SLIF bail synopsis
normalize-whitespace: 1

    my $bail_message = "This is a bail out message!";

    sub do_bail_with_message_if_A {
        my ($action_object, $terminal) = @_;
        Marpa::R2::Context::bail($bail_message) if $terminal eq 'A';
    }

    sub do_bail_with_object_if_A {
        my ($action_object, $terminal) = @_;
        Marpa::R2::Context::bail([$bail_message]) if $terminal eq 'A';
    }

=for Marpa::R2::Display::End

=head1 [This section where?] Parse trees, parse results and parse series

When the semantics are applied to a parse tree,
it produces a value called a B<parse result>.
Because Marpa allows ambiguous parsing,
each parse can produce a B<parse series> --
a series of zero or more parse trees,
each with its own parse result.
The first call to the
L<the recognizer's C<value>
method|Marpa::R2::NAIF::Recognizer/"value">
after the recognizer is created is the
start of the first parse series.
The first parse series continues until there is
a call to the
L<the C<reset_evaluation>
method|Marpa::R2::NAIF::Recognizer/"reset_evaluation">
or until the recognizer is destroyed.
Usually, an application is only interested in a single
parse series.

When the
L<C<reset_evaluation>|Marpa::R2::NAIF::Recognizer/"reset_evaluation">
method
is called
for a recognizer, it begins a new parse series.
The new parse series continues until
there is another
call to the
L<the C<reset_evaluation>
method|Marpa::R2::NAIF::Recognizer/"reset_evaluation">,
or until the recognizer is destroyed.

Most applications will find that the order in which
Marpa executes its semantics "just works".
L<A separate
document|Marpa::R2::Semantics::Phases>
describes that order
in detail.
The details can matter in some applications,
for example, those which exploit side effects.

=head2 Perl object actions

Actions divide into two types:
reserved actions and Perl object actions.
A Perl object action is a actual Perl object of some type:
either code or a reference.

In simplified terms,
if a Perl object action comes from resolution of
an action name,
and
there is a Perl closure of that name, the Perl
closure is the resolution.
If there is a reference with that name
it is resolved
L<as described for Perl reference
actions|/"Reference actions">.
If there is some other scalar with that name,
it is a fatal error.
All other Perl objects with that name are ignored.

More precisely, the resolution depends the lookup
of the action name in the Perl symbol table:

=over 4

=item * 

If there is a C<CODE> entry,
that entry is the resolution.

=item * 

If there is a C<SCALAR> entry,
and it is a reference,
it is resolved
L<as described for Perl reference
actions|/"Reference actions">.

=item * 

If there is a C<SCALAR> entry,
and it is not a reference,
it is a fatal error.

=item * 

If there is no C<SCALAR> entry and no C<CODE> entry,
it will be considered a failure to resolve.

=back

=head2 Reference actions

A Marpa action can be a Perl object which is a reference.
Referents should be treated as read-only constants.
It is possible to modify the values pointed to
by a reference, but the effect will be global,
and this is deprecated as bad practice.
The referents of reference actions should be treated
as read-only, and never modified.

In the following, let C<$action_ref> be the action reference.
Reference actions are handled based on type,
ignoring any blessing as class objects.
This would be the reftype as returned
by C<Scalar::Util::reftype $action_ref>.

If the reftype is C<CODE>,
the resolution is to the Perl closure.
The effect is the same as if an action name
had resolved directly to a closure with the same
name.
The Perl closure,
also called a B<rule evaluation closure>,
will be called to produce the value of
the action.

If the reftype is C<SCALAR>,
the resolution is to its de-referenced value,
C<${$action_ref}>.
The effect is roughly the same as if an action
name had resolved to a closure which returned
C<${$action_ref}>.

If the reftype is C<ARRAY>,
the resolution is to the original reference,
C<$action_ref>.
The effect is roughly the same as if an action
name had resolved to a closure which returned
C<$action_ref>.

If the reftype is C<HASH>,
the resolution is to the original reference,
C<$action_ref>.
The effect is roughly the same as if an action
name had resolved to a closure which returned
C<$action_ref>.

=head2 Modifying Perl object actions

It is important to note multiple invocations
of C<$action_ref> will
always point to the same contents,
and that any modification will be
seen by other invocations.
In other words, the modification will have global
effect.
For this reason modifying the referents of
reference actions is deprecated.

For example,
assume that actions are in a package named C<My_Nodes>,
which contains a hash reference named C<empty_hash>, 

=for Marpa::R2::Display
ignore: 1

        package My_Nodes;
        our $empty_hash = {};

=for Marpa::R2::Display::End

It can be tempting, in building objects which are hashes,
to start with a left node whose action is C<empty_hash>
and to add contents to it as the object is passed up the evaluation
tree.
But C<$empty_hash> points to a single hash object.
This single hash object will shared by all nodes,
with all nodes seeing each other's changes.
Worse, all Marpa parsers which use the same C<My_Nodes>
namespace will share the same hash object.

When not simply a mistake,
this is usually bad programming practice.
Before modifying the referent of a reference action,
rule evaluation closures should copy it.
Safer, if less efficient,
is to define the C<empty_hash> action
as a closure which returns C<{}>.

=head2 Visibility of Perl object actions

It is important to note that,
when Perl closures are used for the semantics,
they must be visible in the scope where the semantics are
B<resolved>.
The action names are usually B<specified> with the grammar,
but action B<resolution> takes place
in the recognizer's
L<C<value>|Marpa::R2::NAIF::Recognizer/"value">
and
L<C<reset_evaluation>|Marpa::R2::NAIF::Recognizer/"reset_evaluation">
methods.
This can sometimes be a source of confusion,
because if a Perl closure is visible when the
action is specified,
but goes out of scope before the action name is resolved,
resolution will fail.

=head1 Draft from here

=head1 The per-parse argument

The first argument of every rule evaluation closure is
the B<per-parse> argument.
This is taken from

=over 4

=item * The result of returned by per-parse constructor if there is one.

=item * Otherwise, the argument to the SLIF recognizer's C<value()> method, if there is one.

=item * If not otherwise specified, the per-parse argument is an empty hash.

=back

The per-parse argument is destroyed once the evaluation of the parse tree is finished.
Between creation and destruction, the per-parse argument is not touched by Marpa's internals --
it is reserved for use by the application.

The primary way of passing data while evaluating a parse tree is purely functional --
results from child nodes are passed up to parent nodes.
Applications can use
the per-parse argument for data which does not conveniently fit the functional model.
Symbol tables are
one common example of data that are best handled outside the functional model.

=head1 The per-parse constructor

The per-parse constructor is the C<new()> method of the semantics package.
If there is no semantics package, or if it has no C<new()> method,
there is no per-parse constructor.

The per-parse construct is called with one argument.
This argument is the argument of the
the SLIF recognizer's C<value()> method, if there one was defined.
Otherwise it is the name of the semantics package.

The result returned by the per-parse constructor becomes the per-parse argument.
The per-parse constructor is called
in the Tree Setup Phase.

=head1 Parse order

If a parse is ambiguous, all parses are returned,
with no duplication.
By default, the order is arbitrary, but
it is also possible to control the order.
Details are in L<the document
on parse order|Marpa::R2::Semantics::Order>.

=head1 Infinite loops

Grammars with infinite loops (cycles)
are generally regarded as useless in practical applications.
Due to lack of interest,
the SLIF does not currently support them,
altougth Libmarpa itself, Marpa's thin interface and the NAIF all do.
Those interested in knowing more can look at L<the
document on the NAIF's support of infinitely ambiguous
grammars|Marpa::R2::NAIF::Semantics::Infinite>.

=head1 Copyright and License

=for Marpa::R2::Display
ignore: 1

  Copyright 2013 Jeffrey Kegler
  This file is part of Marpa::R2.  Marpa::R2 is free software: you can
  redistribute it and/or modify it under the terms of the GNU Lesser
  General Public License as published by the Free Software Foundation,
  either version 3 of the License, or (at your option) any later version.

  Marpa::R2 is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser
  General Public License along with Marpa::R2.  If not, see
  http://www.gnu.org/licenses/.

=for Marpa::R2::Display::End

=cut

# Local Variables:
#   mode: cperl
#   cperl-indent-level: 4
#   fill-column: 100
# End:
# vim: expandtab shiftwidth=4:

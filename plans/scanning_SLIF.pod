# Copyright 2013 Jeffrey Kegler
# This file is part of Marpa::R2.  Marpa::R2 is free software: you can
# redistribute it and/or modify it under the terms of the GNU Lesser
# General Public License as published by the Free Software Foundation,
# either version 3 of the License, or (at your option) any later version.
#
# Marpa::R2 is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser
# General Public License along with Marpa::R2.  If not, see
# http://www.gnu.org/licenses/.

=head1 Name

SLIF Scanning - Adding external scanning to the SLIF interface

=head1 About this document


In this document, use of the Scanless interface's
(SLIF's) internal scanner is called
B<internal scanning>.
The current SLIF only allows internal scanning.
This document describes an interface that allows the use
of an B<external scanner>.
Use of the external scanner is called
B<external scanning>.

The term "scanless" interface is from the parsing
literature.
It is sometimes criticized as misleading because,
of course, an internal scanner is a scanner.
But in the parsing theory literature,
the context of the term is the classic strict definition
of parsing, which required a separate, external scanner as
a previous phase.
A "scannerless" parser was one which did not require
a separate, external scanner because,
at least in effect, it had one that was internal
or "built-in".

=head1 Design considerations

The interface is designed so that it to be
implemented more quickly than more fully featured alternatives:
It is low-level
but open-ended.

This interface allows the user to bring in, or to create,
other scanning tools.
The interface allows the SLIF's internal scanner to by completely bypassed
in favor of an external scanner.
It also allows internal and external scanners to take turns reading
the input string.

The other tools can be arbitrarily powerful.
Techncially, in this interface, they will always
be "subgrammars" of a "parent"
Marpa parser,
but the boundary between scanning and parsing is malleable
enough that,
if an application thinks it necessary,
Marpa and the other tools can in effect share the task of parsing.

=head1 Methods for internal scanning

=head2 Changes to C<Marpa::R2::Scanless::R::read()>.

The C<Marpa::R2::Scanless::R::read()> method remains,
but has two additional arguments,
so that it can be called as
C<< $slr->read($input_string, $start, $length) >>.
The two new arguments, C<$start> and C<$length>, are optional.

The first argument, C<$input_string>, is as before.
As a reminder, this first argument sets the input string for the SLIF.
The input string can only be set once for an SLIF recognizer
and cannot be changed once set.

In C<< $slr->read($input_string, $start, $length) >>,
C<$start> is the position in the input string to begin at,
and C<$length> is the number of codepoints to read.
Negative lengths follow the usual convention so that -1 is the length of the input string.
C<$start> defaults to the "current" position,
and C<$length> defaults to -1, so that the default
In C<< $slr->read($input_string) >> continues to behave as currently implemented.

At present C<read()> is documented as returning a non-negative integer.
In this interface, its return value will be the new current position,
as defined in the next section.

=head2 Current position

The B<current position in the input stream>, more usually simply
called the B<current position>, is a position in the input string.
Positions are zero-based, so that position 0 points to the first
character, if it exists.
A current position equal to the length of the input string
indicates "end of string",
and does
not point to any character.

In this interface, when the current position
moves, it does not necessarily advance -- it
can skip forward,
or can be positioned to an earlier location.
The application can skip sections of the input string.
The application is also free to
revisit spans of the input string as often as it wants.

Here are the guarantees:

=over 4

=item *

Initially, the current position is 0.

=item *

The current position will never be negative.

=item *

The current position will never be past the "end of string".

=back

Current position can be queried with C<< $slr->pos() >>
and set with C<< $slr->pos_set($new_pos) >>.

=head2 How internal scanning works

After the C<read()> method, the current position will indicate how far
in the input stream C<read()> actually read.

=over 4

=item *

As already stated, the current position will never advance past
the end of string.

=item *

If a non-negative C<$length> argument was specified to C<read()>,
C<read()> will not read past a current position of C<$start+$length>.

=item *

If a negative C<$length> argument was specified to C<read()>,
C<read()> will not read past a current position of
C<$length + 1 + length $input_string>.

=item *

The application can specify that the read will
"break" when it encounters certain lexemes,
as specified below.

=item *

An abend
in the C<read()> will cause the current position to
be an unspecified value.

=back

=head2 New C<< $slr->resume($start, $length) >> method

The C<< $slr->resume($start, $length) >> method resumes
the SLIF's internal scanning.
The scan continues as specified by C<$start> and C<$length>,
according to the rules for internal scanning,
as described above.

=head1 Methods for external scanning

=head2 New C<< $slr->g1_alternative($symbol, $value) >> method

The C<< $slr->g1_alternative($symbol, $value) >> method
bypasses G0, reading an alternative directly into G1 with symbol name C<$symbol>,
lexeme value C<$value>.

=head2 New C<< $slr->g1_lexeme_complete($start, $length) >> method

A new C<< $slr->g1_lexeme_complete($start, $length) >> method will
correspond to an C<earleme_complete()> for G1.
Current position in the input stream
will be moved to C<$start+$length>.

=head2 New C<< $slr->g1_read_lexeme($symbol_name, $value, $start, $length) >> method

Add a C<< $slr->g1_read_lexeme($symbol_name, $value, $start, $length) >> method,
which is the equivalent of C<< $slr->g1_alternative($symbol, $value) >>,
followed by C<< $slr->g1_lexeme_complete($start, $length) >>.
Current position in the input stream
will be moved to C<$start+$length>.

=head2 The input string

For error message purposes,
even external lexemes are required to correspond to a span of the input string.
If an applications uses external lexemes which have
no natural relationship
to a span of the input string, it must arrange an artifical one.

One way to do this is to have a artificial preamble to the real text.
For example, the first 7 characters of the input string could be
the artificial preamble containing the characters "C<NO TEXT>",
which is then followed by what the application considers
the "real" text.
In this case, the first C<read()> could take the form
C<< $slr->read($input_string, 7) >>.
Lexemes corresponding to the artificial preamble would be read
with method calls similar to
C<< $slr->g1_read_lexeme($symbol_name, $value, 0, 42) >>.

=head1 Breaking away from of the internal scan

=head2 C<:lexeme> psueudo-rules

      :lexeme ::= variable break => reject

The SLIF DSL will be extended to include lexeme pseudo-rules.
Initially, their purpose would be to support the C<break> adverb,
as described in the next section.

As a side effect, the C<:lexeme> will allow applications to declare
symbols to be lexemes.
The previous definition of lexeme will continue to apply,
so that the only effect of these "lexeme declarations"
will be to cause a fatal error if the declared lexeme
is not a lexeme
according to the previous rules.
Applications may find this behavior useful for debugging,
and for documentatiing their gramamrs.

=head2 The C<break> adverb

C<:lexeme> pseudo-rules
The SLIF DSL, adverbs will have a new C<break> adverb.
If C<break> is set, a C<Marpa::R2::Scanless::R::read()> will stop when that lexeme is encountered.
Possible values of C<break> are C<accept>, C<reject> and C<skip>.
If the value of C<break> is C<accept>, the lexeme is read, otherwise it is not read.

If at a given G1 parse location,
one of the values of C<break> is either C<accept> or C<skip>,
the current position in the input stream will be at the position 
where the lexeme ended.
If at a given G1 parse location,
all of the values of C<break> are C<reject>,
the current position in the input stream will be at the position
where the lexeme started.

=head1 Capabilities

=head2 Replacing the Stuifzand (BNF) interface

Once the SLIF allows the user to provide their own scanner,
the separate Stuifzand (BNF) interface will
no longer serve any purpose,
and will be de-emphasized.

=head2 Backtracking and lookahead

Most of the desire to backtrack and perform lookahead for Marpa
comes from an underappreciation of its capabilities.
Nonetheless, there are some situations where backtracking
and/or lookahead is genuinely useful with Marpa.
And the ability to backtrack and look ahead will keep
programmers used to weaker parsers in their "comfort zone".

=head2 Subgrammars

The scanner could, in fact, be a subgrammar.
The subgrammar could, be another, specialized,
Marpa grammar.
Or it could be another grammar
that is thought to
work better for portions of the
parse, hooked up as a "subgrammar".
For example, the application could switch back and forth
between Marpa and regular expressions,
or between Marpa and recursive descent.

=head2 G0 actions

Currently the G0 grammar cannot perform actions -- it can only
recognize literal lexemes.
As a special case of subgrammar use,
another Marpa parser can be hooked up
that performs actions and returns the result to
the parent grammar via C<g1_read>.

=head2 Other possibilities

The interface is in fact open-ended.

=head1 Copyright and License

=for Marpa::R2::Display
ignore: 1

  Copyright 2013 Jeffrey Kegler
  This file is part of Marpa::R2.  Marpa::R2 is free software: you can
  redistribute it and/or modify it under the terms of the GNU Lesser
  General Public License as published by the Free Software Foundation,
  either version 3 of the License, or (at your option) any later version.

  Marpa::R2 is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser
  General Public License along with Marpa::R2.  If not, see
  http://www.gnu.org/licenses/.

=for Marpa::R2::Display::End

=cut

# vim: expandtab shiftwidth=4:

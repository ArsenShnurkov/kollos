# Copyright 2013 Jeffrey Kegler
# This file is part of Marpa::R2.  Marpa::R2 is free software: you can
# redistribute it and/or modify it under the terms of the GNU Lesser
# General Public License as published by the Free Software Foundation,
# either version 3 of the License, or (at your option) any later version.
#
# Marpa::R2 is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser
# General Public License along with Marpa::R2.  If not, see
# http://www.gnu.org/licenses/.

=head1 NAME

SLIF Scanning - Proposed SLIF interface for custom scanners

=head1 About this document

This is an outline of a proposed extension to the Scanless interface (SLIF)
that will allow it to support an application's customized scanning.
Scanning can be handed over entirely to the application,
and they can switch back and forth.

=head1 Design considerations

The interface is designed so that it could be
implemented fairly quickly.
The interface is low-level
and open-ended.
Tt allows the user to bring in, or to create,
powerful scanning tools to supplement the SLIF's scanning,
and even to augment Marpa's parsing, if that is thought
necessary.

=head1 Details of the proposed interface

=head2 Extending C<Marpa::R2::Scanless::R::read()>.

Add two optional parameters to C<Marpa::R2::Scanless::R::read()>.
In C<< $slr->read($input_string, $start, $length) >>,
C<$start> is the position in the input string to begin at,
and C<$length> is the number of codepoints to read.
Negative lengths follow the usual convention so that -1 is the length of the input string.
C<$start> defaults to the "current" position,
and C<$length> defaults to -1, so that the default
In C<< $slr->read($input_string) >> continues to behave as currently implemented.

The C<read> method advances the current position to C<$start+$length>.
The current position is initialized to pos 0.

=head2 A new C<< $slr->g1_alternative($symbol, $value) >> method

Add a C<< $slr->g1_alternative($symbol, $value) >>
method.
This bypasses G0, reading an alternative directly into G1 with symbol name symbol, lexeme value value.

=head2 C<< $slr->g1_lexeme_complete($start, $length) >>

Add a C<< $slr->g1_lexeme_complete($start, $length) >> method,
corresponding to an C<earleme_complete()> for G1.
Current position will be moved to C<$start+$length>.

=head2 C<< $slr->g1_read_lexeme($symbol_name, $value, $start, $length) >

Add a C<< $slr->g1_read_lexeme($symbol_name, $value, $start, $length) >> method,
which is the equivalent of C<< $slr->g1_alternative($symbol, $value) >>,
followed by C<< $slr->g1_lexeme_complete(start, length) >>.

=head2 Jumping around in the input string

If only for error message purposes,
all lexemes correspond to a span of the input string, but this correspondence need only be conceptual.
For example, you could put some sort of error message in the first 42 characters, start the main reading after them with
C<< $slr->read($input_string, 42) >>,
and read all your custom lexemes with C<< $slr->g1_read_lexeme($symbol_name, $value, 0, 42) >>.

=head2 The C<break> adverb

In the
SLIF DSL, adverbs will have a new C<break> adverb.
If C<break> is set, a C<Marpa::R2::Scanless::R::read()> will stop when that lexeme is encountered.
Possible values of C<break> are:

=over 4

=item C<accept>

The lexeme is read.
Current position is set to the position where the lexeme ended.

=item C<reject>

The lexeme is B<not> read.
Current position is set to the position where the lexeme started.

=item C<skip>

The lexeme is B<not> read.
Current position is set to the position where the lexeme ended.

=back

=head2 The current position

An important part of this interface is its idea of
"current" position, which has been referred to several times above.
Current position can be queried with C<< $slr->pos() >>
and set with C<< $slr->pos_set($new_pos) >>.

=head1 Capabilities

=head2 Replacing the Stuifzand (BNF) interface

Once the SLIF allows the user to provide their own scanner,
the separate Stuifzand (BNF) interface will
no longer serve any purpose,
and will be de-emphasized.

=head2 Backtracking and lookahead

Most of the desire to backtrack and perform lookahead for Marpa
comes from an underappreciation of its capabilities.
Nonetheless, there are some situations where backtracking
and/or lookahead is genuinely useful with Marpa.
And the ability to backtrack and look ahead will keep
programmers used to weaker parsers in their "comfort zone".

=head2 Subgrammars

The scanner could, in fact, be a subgrammar.
The subgrammar could, be another, specialized,
Marpa grammar.
Or it could be another grammar
that is work better for portions of the
parse, hooked up as a "subgrammar".
For example, the application could switch back and forth
between Marpa and regular expressions,
or between Marpa and recursive descent.

=head2 G0 actions

Currently the G0 grammar cannot perform actions -- it can only
recognize literal lexemes.
As a special case of subgrammar use,
another Marpa parser can be hooked up
that performs actions and returns the result to
the parent grammar via C<g1_read>.

=head2 Other possibilities

The interface is in fact open-ended.

=head1 Copyright and License

=for Marpa::R2::Display
ignore: 1

  Copyright 2013 Jeffrey Kegler
  This file is part of Marpa::R2.  Marpa::R2 is free software: you can
  redistribute it and/or modify it under the terms of the GNU Lesser
  General Public License as published by the Free Software Foundation,
  either version 3 of the License, or (at your option) any later version.

  Marpa::R2 is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser
  General Public License along with Marpa::R2.  If not, see
  http://www.gnu.org/licenses/.

=for Marpa::R2::Display::End

=cut

# vim: expandtab shiftwidth=4:
